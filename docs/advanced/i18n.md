# Internationalization (i18n)

Build multi-language PhilJS applications with internationalization support.

## What You'll Learn

- i18n fundamentals
- Setting up i18n
- Translation management
- Locale switching
- Date and number formatting
- RTL support
- Best practices

## Why i18n?

Internationalization enables:

- **Global Reach**: Serve users in their native language
- **Better UX**: Users prefer content in their language
- **Market Expansion**: Enter new markets easily
- **Compliance**: Meet regional requirements
- **Accessibility**: Support diverse audiences

## Basic Setup

### Install i18n Library

```bash
npm install @phil

js/i18n
```

### Configure i18n

```typescript
// src/i18n/config.ts
import { createI18n } from '@philjs/i18n';

export const i18n = createI18n({
  defaultLocale: 'en',
  locales: ['en', 'es', 'fr', 'de', 'ja'],
  fallbackLocale: 'en'
});

export type Locale = 'en' | 'es' | 'fr' | 'de' | 'ja';
```

### Translation Files

```typescript
// src/i18n/locales/en.ts
export const en = {
  common: {
    welcome: 'Welcome',
    goodbye: 'Goodbye',
    submit: 'Submit',
    cancel: 'Cancel'
  },
  nav: {
    home: 'Home',
    about: 'About',
    contact: 'Contact'
  },
  auth: {
    login: 'Log In',
    logout: 'Log Out',
    register: 'Register',
    forgotPassword: 'Forgot Password?'
  },
  errors: {
    notFound: 'Page not found',
    serverError: 'Internal server error',
    unauthorized: 'Unauthorized access'
  }
};

// src/i18n/locales/es.ts
export const es = {
  common: {
    welcome: 'Bienvenido',
    goodbye: 'Adiós',
    submit: 'Enviar',
    cancel: 'Cancelar'
  },
  nav: {
    home: 'Inicio',
    about: 'Acerca de',
    contact: 'Contacto'
  },
  auth: {
    login: 'Iniciar Sesión',
    logout: 'Cerrar Sesión',
    register: 'Registrarse',
    forgotPassword: '¿Olvidaste tu contraseña?'
  },
  errors: {
    notFound: 'Página no encontrada',
    serverError: 'Error interno del servidor',
    unauthorized: 'Acceso no autorizado'
  }
};

// src/i18n/locales/fr.ts
export const fr = {
  common: {
    welcome: 'Bienvenue',
    goodbye: 'Au revoir',
    submit: 'Soumettre',
    cancel: 'Annuler'
  },
  nav: {
    home: 'Accueil',
    about: 'À propos',
    contact: 'Contact'
  },
  auth: {
    login: 'Se connecter',
    logout: 'Se déconnecter',
    register: "S'inscrire",
    forgotPassword: 'Mot de passe oublié?'
  },
  errors: {
    notFound: 'Page non trouvée',
    serverError: 'Erreur interne du serveur',
    unauthorized: 'Accès non autorisé'
  }
};
```

### Translations Index

```typescript
// src/i18n/locales/index.ts
import { en } from './en';
import { es } from './es';
import { fr } from './fr';

export const translations = {
  en,
  es,
  fr
};

export type Translations = typeof en;
export type TranslationKey = keyof Translations;
```

## Using Translations

### i18n Context Provider

```typescript
import { createContext, useContext, signal } from 'philjs-core';
import type { Locale, Translations } from './locales';
import { translations } from './locales';

interface I18nContext {
  locale: () => Locale;
  setLocale: (locale: Locale) => void;
  t: (key: string, params?: Record<string, any>) => string;
}

const I18nContext = createContext<I18nContext | null>(null);

export function useI18n() {
  const context = useContext(I18nContext);
  if (!context) {
    throw new Error('useI18n must be used within I18nProvider');
  }
  return context;
}

export function I18nProvider({ children }: { children: JSX.Element }) {
  const locale = signal<Locale>('en');

  const t = (key: string, params?: Record<string, any>): string => {
    const keys = key.split('.');
    let value: any = translations[locale()];

    for (const k of keys) {
      value = value?.[k];
    }

    if (typeof value !== 'string') {
      console.warn(`Translation missing: ${key}`);
      return key;
    }

    // Replace parameters
    if (params) {
      return Object.entries(params).reduce(
        (str, [param, val]) => str.replace(`{${param}}`, String(val)),
        value
      );
    }

    return value;
  };

  return (
    <I18nContext.Provider
      value={{
        locale,
        setLocale: (newLocale) => locale.set(newLocale),
        t
      }}
    >
      {children}
    </I18nContext.Provider>
  );
}
```

### Using Translations in Components

```typescript
import { useI18n } from './i18n';

function WelcomeMessage() {
  const { t } = useI18n();

  return (
    <div>
      <h1>{t('common.welcome')}</h1>
      <p>{t('common.goodbye')}</p>
    </div>
  );
}

function UserGreeting({ name }: { name: string }) {
  const { t } = useI18n();

  return <p>{t('greeting', { name })}</p>;
  // Assuming translation: "Hello, {name}!"
  // Output: "Hello, John!"
}
```

## Locale Switching

### Language Selector

```typescript
import { useI18n } from './i18n';

const languages = [
  { code: 'en', name: 'English', flag: '🇺🇸' },
  { code: 'es', name: 'Español', flag: '🇪🇸' },
  { code: 'fr', name: 'Français', flag: '🇫🇷' },
  { code: 'de', name: 'Deutsch', flag: '🇩🇪' },
  { code: 'ja', name: '日本語', flag: '🇯🇵' }
];

export function LanguageSelector() {
  const { locale, setLocale } = useI18n();
  const isOpen = signal(false);

  return (
    <div className="language-selector">
      <button onClick={() => isOpen.set(!isOpen())}>
        {languages.find(l => l.code === locale())?.flag} {locale().toUpperCase()}
      </button>

      {isOpen() && (
        <div className="language-menu">
          {languages.map(lang => (
            <button
              key={lang.code}
              onClick={() => {
                setLocale(lang.code as Locale);
                isOpen.set(false);
              }}
              className={locale() === lang.code ? 'active' : ''}
            >
              {lang.flag} {lang.name}
            </button>
          ))}
        </div>
      )}
    </div>
  );
}
```

### Persist Locale Preference

```typescript
import { effect } from 'philjs-core';

export function I18nProvider({ children }: { children: JSX.Element }) {
  // Load saved locale from localStorage
  const savedLocale = localStorage.getItem('locale') as Locale || 'en';
  const locale = signal<Locale>(savedLocale);

  // Save locale changes to localStorage
  effect(() => {
    localStorage.setItem('locale', locale());
  });

  const t = (key: string, params?: Record<string, any>): string => {
    // ... translation logic
  };

  return (
    <I18nContext.Provider value={{ locale, setLocale: locale.set, t }}>
      {children}
    </I18nContext.Provider>
  );
}
```

### URL-Based Locale

```typescript
import { Router, Route, useRouter } from 'philjs-router';

function App() {
  return (
    <Router>
      <Route path="/:locale/*" component={LocalizedApp} />
      <Route path="/*" component={() => <Redirect to="/en" />} />
    </Router>
  );
}

function LocalizedApp() {
  const { params } = useRouter();
  const locale = params.locale as Locale;

  return (
    <I18nProvider initialLocale={locale}>
      <AppContent />
    </I18nProvider>
  );
}

// Update setLocale to change URL
const setLocale = (newLocale: Locale) => {
  const path = window.location.pathname.split('/').slice(2).join('/');
  window.location.pathname = `/${newLocale}/${path}`;
};
```

## Formatting

### Date Formatting

```typescript
export function useI18n() {
  const context = useContext(I18nContext);

  const formatDate = (date: Date, options?: Intl.DateTimeFormatOptions) => {
    return new Intl.DateTimeFormat(context.locale(), options).format(date);
  };

  const formatRelativeTime = (date: Date): string => {
    const now = new Date();
    const diff = date.getTime() - now.getTime();
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    const rtf = new Intl.RelativeTimeFormat(context.locale(), {
      numeric: 'auto'
    });

    if (Math.abs(days) > 0) return rtf.format(days, 'day');
    if (Math.abs(hours) > 0) return rtf.format(hours, 'hour');
    if (Math.abs(minutes) > 0) return rtf.format(minutes, 'minute');
    return rtf.format(seconds, 'second');
  };

  return {
    ...context,
    formatDate,
    formatRelativeTime
  };
}

// Usage
function BlogPost({ post }: { post: Post }) {
  const { formatDate, formatRelativeTime } = useI18n();

  return (
    <article>
      <h1>{post.title}</h1>
      <time>{formatDate(new Date(post.date), { dateStyle: 'long' })}</time>
      <p>{formatRelativeTime(new Date(post.date))}</p>
    </article>
  );
}
```

### Number Formatting

```typescript
export function useI18n() {
  const context = useContext(I18nContext);

  const formatNumber = (value: number, options?: Intl.NumberFormatOptions) => {
    return new Intl.NumberFormat(context.locale(), options).format(value);
  };

  const formatCurrency = (value: number, currency: string = 'USD') => {
    return new Intl.NumberFormat(context.locale(), {
      style: 'currency',
      currency
    }).format(value);
  };

  const formatPercent = (value: number) => {
    return new Intl.NumberFormat(context.locale(), {
      style: 'percent',
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    }).format(value);
  };

  return {
    ...context,
    formatNumber,
    formatCurrency,
    formatPercent
  };
}

// Usage
function ProductPrice({ price, currency }: { price: number; currency: string }) {
  const { formatCurrency } = useI18n();

  return <span className="price">{formatCurrency(price, currency)}</span>;
}
```

### List Formatting

```typescript
export function useI18n() {
  const context = useContext(I18nContext);

  const formatList = (items: string[], type: 'conjunction' | 'disjunction' = 'conjunction') => {
    return new Intl.ListFormat(context.locale(), {
      style: 'long',
      type
    }).format(items);
  };

  return {
    ...context,
    formatList
  };
}

// Usage
function TagList({ tags }: { tags: string[] }) {
  const { formatList } = useI18n();

  return <p>Tags: {formatList(tags)}</p>;
  // en: "Tags: React, TypeScript, and JavaScript"
  // es: "Tags: React, TypeScript y JavaScript"
}
```

## Pluralization

### Plural Rules

```typescript
export function useI18n() {
  const context = useContext(I18nContext);

  const plural = (
    count: number,
    translations: { zero?: string; one: string; other: string }
  ): string => {
    const rules = new Intl.PluralRules(context.locale());
    const rule = rules.select(count);

    if (count === 0 && translations.zero) {
      return translations.zero.replace('{count}', String(count));
    }

    const translation = translations[rule as 'one' | 'other'] || translations.other;
    return translation.replace('{count}', String(count));
  };

  return {
    ...context,
    plural
  };
}

// Usage
function ItemCount({ count }: { count: number }) {
  const { plural } = useI18n();

  return (
    <p>
      {plural(count, {
        zero: 'No items',
        one: '{count} item',
        other: '{count} items'
      })}
    </p>
  );
}
```

## RTL Support

### Detect RTL Languages

```typescript
const RTL_LANGUAGES = ['ar', 'he', 'fa', 'ur'];

export function useI18n() {
  const context = useContext(I18nContext);

  const isRTL = () => RTL_LANGUAGES.includes(context.locale());
  const direction = () => isRTL() ? 'rtl' : 'ltr';

  return {
    ...context,
    isRTL,
    direction
  };
}
```

### Apply RTL Styles

```typescript
import { effect } from 'philjs-core';
import { useI18n } from './i18n';

function App() {
  const { direction } = useI18n();

  effect(() => {
    document.documentElement.dir = direction();
    document.documentElement.lang = locale();
  });

  return <div>{/* app content */}</div>;
}
```

### RTL-Aware Styles

```css
/* Logical properties (automatically flip in RTL) */
.container {
  margin-inline-start: 20px; /* margin-left in LTR, margin-right in RTL */
  padding-inline-end: 10px;  /* padding-right in LTR, padding-left in RTL */
}

/* RTL-specific styles */
[dir='rtl'] .icon {
  transform: scaleX(-1); /* Flip icons */
}

[dir='rtl'] .text {
  text-align: right;
}
```

## Lazy Loading Translations

```typescript
async function loadTranslations(locale: Locale): Promise<Translations> {
  const module = await import(`./locales/${locale}.ts`);
  return module.default;
}

export function I18nProvider({ children }: { children: JSX.Element }) {
  const locale = signal<Locale>('en');
  const translations = signal<Translations | null>(null);

  effect(async () => {
    const trans = await loadTranslations(locale());
    translations.set(trans);
  });

  if (!translations()) {
    return <div>Loading translations...</div>;
  }

  const t = (key: string): string => {
    const keys = key.split('.');
    let value: any = translations();

    for (const k of keys) {
      value = value?.[k];
    }

    return typeof value === 'string' ? value : key;
  };

  return (
    <I18nContext.Provider value={{ locale, setLocale: locale.set, t }}>
      {children}
    </I18nContext.Provider>
  );
}
```

## Best Practices

### Type-Safe Translations

```typescript
// Generate types from translations
type DeepKeys<T, K extends string = ''> = T extends object
  ? {
      [P in keyof T]: P extends string
        ? DeepKeys<T[P], `${K}${K extends '' ? '' : '.'}${P}`>
        : never;
    }[keyof T]
  : K;

type TranslationKeys = DeepKeys<typeof en>;

// Type-safe t function
const t = (key: TranslationKeys, params?: Record<string, any>): string => {
  // ... implementation
};

// Usage - autocomplete and type checking!
t('common.welcome'); // ✓
t('nav.home'); // ✓
t('invalid.key'); // ✗ Type error
```

### Extract Reusable Strings

```typescript
// ✅ Keep UI strings in translations
const translations = {
  buttons: {
    save: 'Save',
    cancel: 'Cancel',
    delete: 'Delete'
  }
};

// ❌ Don't hardcode strings
<button>Save</button>

// ✅ Use translations
<button>{t('buttons.save')}</button>
```

### Namespace Translations

```typescript
// Group related translations
export const en = {
  pages: {
    home: {
      title: 'Welcome Home',
      subtitle: 'Get started with PhilJS'
    },
    about: {
      title: 'About Us',
      description: 'Learn more about our company'
    }
  },
  components: {
    header: {
      login: 'Log In',
      signup: 'Sign Up'
    }
  }
};
```

### Handle Missing Translations

```typescript
const t = (key: string, params?: Record<string, any>): string => {
  const keys = key.split('.');
  let value: any = translations[locale()];

  for (const k of keys) {
    value = value?.[k];
  }

  // Missing translation - try fallback locale
  if (typeof value !== 'string') {
    value = translations[fallbackLocale];
    for (const k of keys) {
      value = value?.[k];
    }
  }

  // Still missing - log warning and return key
  if (typeof value !== 'string') {
    console.warn(`Missing translation: ${key} for locale ${locale()}`);
    return key;
  }

  return value;
};
```

## Summary

You've learned:

✅ i18n fundamentals and setup
✅ Translation file organization
✅ Using translations in components
✅ Locale switching and persistence
✅ Date, number, and list formatting
✅ Pluralization support
✅ RTL language support
✅ Lazy loading translations
✅ Type-safe translations
✅ Best practices for i18n

i18n enables your app to reach a global audience!

---

**Next:** [Authentication →](./authentication.md) Secure your application
