# Internationalization (i18n)

Build multi-language PhilJS applications with internationalization support.

## What You'll Learn

- i18n fundamentals
- Setting up i18n
- Translation management
- Locale switching
- Date and number formatting
- RTL support
- Best practices

## Why i18n?

Internationalization enables:

- **Global Reach**: Serve users in their native language
- **Better UX**: Users prefer content in their language
- **Market Expansion**: Enter new markets easily
- **Compliance**: Meet regional requirements
- **Accessibility**: Support diverse audiences

## Basic Setup

### Install i18n Library

```bash
npm install @phil

js/i18n
```

### Configure i18n

```typescript
// src/i18n/config.ts
import { createI18n } from '@philjs/i18n';

export const i18n = createI18n({
  defaultLocale: 'en',
  locales: ['en', 'es', 'fr', 'de', 'ja'],
  fallbackLocale: 'en'
});

export type Locale = 'en' | 'es' | 'fr' | 'de' | 'ja';
```

### Translation Files

```typescript
// src/i18n/locales/en.ts
export const en = {
  common: {
    welcome: 'Welcome',
    goodbye: 'Goodbye',
    submit: 'Submit',
    cancel: 'Cancel'
  },
  nav: {
    home: 'Home',
    about: 'About',
    contact: 'Contact'
  },
  auth: {
    login: 'Log In',
    logout: 'Log Out',
    register: 'Register',
    forgotPassword: 'Forgot Password?'
  },
  errors: {
    notFound: 'Page not found',
    serverError: 'Internal server error',
    unauthorized: 'Unauthorized access'
  }
};

// src/i18n/locales/es.ts
export const es = {
  common: {
    welcome: 'Bienvenido',
    goodbye: 'Adi√≥s',
    submit: 'Enviar',
    cancel: 'Cancelar'
  },
  nav: {
    home: 'Inicio',
    about: 'Acerca de',
    contact: 'Contacto'
  },
  auth: {
    login: 'Iniciar Sesi√≥n',
    logout: 'Cerrar Sesi√≥n',
    register: 'Registrarse',
    forgotPassword: '¬øOlvidaste tu contrase√±a?'
  },
  errors: {
    notFound: 'P√°gina no encontrada',
    serverError: 'Error interno del servidor',
    unauthorized: 'Acceso no autorizado'
  }
};

// src/i18n/locales/fr.ts
export const fr = {
  common: {
    welcome: 'Bienvenue',
    goodbye: 'Au revoir',
    submit: 'Soumettre',
    cancel: 'Annuler'
  },
  nav: {
    home: 'Accueil',
    about: '√Ä propos',
    contact: 'Contact'
  },
  auth: {
    login: 'Se connecter',
    logout: 'Se d√©connecter',
    register: "S'inscrire",
    forgotPassword: 'Mot de passe oubli√©?'
  },
  errors: {
    notFound: 'Page non trouv√©e',
    serverError: 'Erreur interne du serveur',
    unauthorized: 'Acc√®s non autoris√©'
  }
};
```

### Translations Index

```typescript
// src/i18n/locales/index.ts
import { en } from './en';
import { es } from './es';
import { fr } from './fr';

export const translations = {
  en,
  es,
  fr
};

export type Translations = typeof en;
export type TranslationKey = keyof Translations;
```

## Using Translations

### i18n Context Provider

```typescript
import { createContext, useContext, signal } from 'philjs-core';
import type { Locale, Translations } from './locales';
import { translations } from './locales';

interface I18nContext {
  locale: () => Locale;
  setLocale: (locale: Locale) => void;
  t: (key: string, params?: Record<string, any>) => string;
}

const I18nContext = createContext<I18nContext | null>(null);

export function useI18n() {
  const context = useContext(I18nContext);
  if (!context) {
    throw new Error('useI18n must be used within I18nProvider');
  }
  return context;
}

export function I18nProvider({ children }: { children: JSX.Element }) {
  const locale = signal<Locale>('en');

  const t = (key: string, params?: Record<string, any>): string => {
    const keys = key.split('.');
    let value: any = translations[locale()];

    for (const k of keys) {
      value = value?.[k];
    }

    if (typeof value !== 'string') {
      console.warn(`Translation missing: ${key}`);
      return key;
    }

    // Replace parameters
    if (params) {
      return Object.entries(params).reduce(
        (str, [param, val]) => str.replace(`{${param}}`, String(val)),
        value
      );
    }

    return value;
  };

  return (
    <I18nContext.Provider
      value={{
        locale,
        setLocale: (newLocale) => locale.set(newLocale),
        t
      }}
    >
      {children}
    </I18nContext.Provider>
  );
}
```

### Using Translations in Components

```typescript
import { useI18n } from './i18n';

function WelcomeMessage() {
  const { t } = useI18n();

  return (
    <div>
      <h1>{t('common.welcome')}</h1>
      <p>{t('common.goodbye')}</p>
    </div>
  );
}

function UserGreeting({ name }: { name: string }) {
  const { t } = useI18n();

  return <p>{t('greeting', { name })}</p>;
  // Assuming translation: "Hello, {name}!"
  // Output: "Hello, John!"
}
```

## Locale Switching

### Language Selector

```typescript
import { useI18n } from './i18n';

const languages = [
  { code: 'en', name: 'English', flag: 'üá∫üá∏' },
  { code: 'es', name: 'Espa√±ol', flag: 'üá™üá∏' },
  { code: 'fr', name: 'Fran√ßais', flag: 'üá´üá∑' },
  { code: 'de', name: 'Deutsch', flag: 'üá©üá™' },
  { code: 'ja', name: 'Êó•Êú¨Ë™û', flag: 'üáØüáµ' }
];

export function LanguageSelector() {
  const { locale, setLocale } = useI18n();
  const isOpen = signal(false);

  return (
    <div className="language-selector">
      <button onClick={() => isOpen.set(!isOpen())}>
        {languages.find(l => l.code === locale())?.flag} {locale().toUpperCase()}
      </button>

      {isOpen() && (
        <div className="language-menu">
          {languages.map(lang => (
            <button
              key={lang.code}
              onClick={() => {
                setLocale(lang.code as Locale);
                isOpen.set(false);
              }}
              className={locale() === lang.code ? 'active' : ''}
            >
              {lang.flag} {lang.name}
            </button>
          ))}
        </div>
      )}
    </div>
  );
}
```

### Persist Locale Preference

```typescript
import { effect } from 'philjs-core';

export function I18nProvider({ children }: { children: JSX.Element }) {
  // Load saved locale from localStorage
  const savedLocale = localStorage.getItem('locale') as Locale || 'en';
  const locale = signal<Locale>(savedLocale);

  // Save locale changes to localStorage
  effect(() => {
    localStorage.setItem('locale', locale());
  });

  const t = (key: string, params?: Record<string, any>): string => {
    // ... translation logic
  };

  return (
    <I18nContext.Provider value={{ locale, setLocale: locale.set, t }}>
      {children}
    </I18nContext.Provider>
  );
}
```

### URL-Based Locale

```typescript
import { Router, Route, useRouter } from 'philjs-router';

function App() {
  return (
    <Router>
      <Route path="/:locale/*" component={LocalizedApp} />
      <Route path="/*" component={() => <Redirect to="/en" />} />
    </Router>
  );
}

function LocalizedApp() {
  const { params } = useRouter();
  const locale = params.locale as Locale;

  return (
    <I18nProvider initialLocale={locale}>
      <AppContent />
    </I18nProvider>
  );
}

// Update setLocale to change URL
const setLocale = (newLocale: Locale) => {
  const path = window.location.pathname.split('/').slice(2).join('/');
  window.location.pathname = `/${newLocale}/${path}`;
};
```

## Formatting

### Date Formatting

```typescript
export function useI18n() {
  const context = useContext(I18nContext);

  const formatDate = (date: Date, options?: Intl.DateTimeFormatOptions) => {
    return new Intl.DateTimeFormat(context.locale(), options).format(date);
  };

  const formatRelativeTime = (date: Date): string => {
    const now = new Date();
    const diff = date.getTime() - now.getTime();
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    const rtf = new Intl.RelativeTimeFormat(context.locale(), {
      numeric: 'auto'
    });

    if (Math.abs(days) > 0) return rtf.format(days, 'day');
    if (Math.abs(hours) > 0) return rtf.format(hours, 'hour');
    if (Math.abs(minutes) > 0) return rtf.format(minutes, 'minute');
    return rtf.format(seconds, 'second');
  };

  return {
    ...context,
    formatDate,
    formatRelativeTime
  };
}

// Usage
function BlogPost({ post }: { post: Post }) {
  const { formatDate, formatRelativeTime } = useI18n();

  return (
    <article>
      <h1>{post.title}</h1>
      <time>{formatDate(new Date(post.date), { dateStyle: 'long' })}</time>
      <p>{formatRelativeTime(new Date(post.date))}</p>
    </article>
  );
}
```

### Number Formatting

```typescript
export function useI18n() {
  const context = useContext(I18nContext);

  const formatNumber = (value: number, options?: Intl.NumberFormatOptions) => {
    return new Intl.NumberFormat(context.locale(), options).format(value);
  };

  const formatCurrency = (value: number, currency: string = 'USD') => {
    return new Intl.NumberFormat(context.locale(), {
      style: 'currency',
      currency
    }).format(value);
  };

  const formatPercent = (value: number) => {
    return new Intl.NumberFormat(context.locale(), {
      style: 'percent',
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    }).format(value);
  };

  return {
    ...context,
    formatNumber,
    formatCurrency,
    formatPercent
  };
}

// Usage
function ProductPrice({ price, currency }: { price: number; currency: string }) {
  const { formatCurrency } = useI18n();

  return <span className="price">{formatCurrency(price, currency)}</span>;
}
```

### List Formatting

```typescript
export function useI18n() {
  const context = useContext(I18nContext);

  const formatList = (items: string[], type: 'conjunction' | 'disjunction' = 'conjunction') => {
    return new Intl.ListFormat(context.locale(), {
      style: 'long',
      type
    }).format(items);
  };

  return {
    ...context,
    formatList
  };
}

// Usage
function TagList({ tags }: { tags: string[] }) {
  const { formatList } = useI18n();

  return <p>Tags: {formatList(tags)}</p>;
  // en: "Tags: React, TypeScript, and JavaScript"
  // es: "Tags: React, TypeScript y JavaScript"
}
```

## Pluralization

### Plural Rules

```typescript
export function useI18n() {
  const context = useContext(I18nContext);

  const plural = (
    count: number,
    translations: { zero?: string; one: string; other: string }
  ): string => {
    const rules = new Intl.PluralRules(context.locale());
    const rule = rules.select(count);

    if (count === 0 && translations.zero) {
      return translations.zero.replace('{count}', String(count));
    }

    const translation = translations[rule as 'one' | 'other'] || translations.other;
    return translation.replace('{count}', String(count));
  };

  return {
    ...context,
    plural
  };
}

// Usage
function ItemCount({ count }: { count: number }) {
  const { plural } = useI18n();

  return (
    <p>
      {plural(count, {
        zero: 'No items',
        one: '{count} item',
        other: '{count} items'
      })}
    </p>
  );
}
```

## RTL Support

### Detect RTL Languages

```typescript
const RTL_LANGUAGES = ['ar', 'he', 'fa', 'ur'];

export function useI18n() {
  const context = useContext(I18nContext);

  const isRTL = () => RTL_LANGUAGES.includes(context.locale());
  const direction = () => isRTL() ? 'rtl' : 'ltr';

  return {
    ...context,
    isRTL,
    direction
  };
}
```

### Apply RTL Styles

```typescript
import { effect } from 'philjs-core';
import { useI18n } from './i18n';

function App() {
  const { direction } = useI18n();

  effect(() => {
    document.documentElement.dir = direction();
    document.documentElement.lang = locale();
  });

  return <div>{/* app content */}</div>;
}
```

### RTL-Aware Styles

```css
/* Logical properties (automatically flip in RTL) */
.container {
  margin-inline-start: 20px; /* margin-left in LTR, margin-right in RTL */
  padding-inline-end: 10px;  /* padding-right in LTR, padding-left in RTL */
}

/* RTL-specific styles */
[dir='rtl'] .icon {
  transform: scaleX(-1); /* Flip icons */
}

[dir='rtl'] .text {
  text-align: right;
}
```

## Lazy Loading Translations

```typescript
async function loadTranslations(locale: Locale): Promise<Translations> {
  const module = await import(`./locales/${locale}.ts`);
  return module.default;
}

export function I18nProvider({ children }: { children: JSX.Element }) {
  const locale = signal<Locale>('en');
  const translations = signal<Translations | null>(null);

  effect(async () => {
    const trans = await loadTranslations(locale());
    translations.set(trans);
  });

  if (!translations()) {
    return <div>Loading translations...</div>;
  }

  const t = (key: string): string => {
    const keys = key.split('.');
    let value: any = translations();

    for (const k of keys) {
      value = value?.[k];
    }

    return typeof value === 'string' ? value : key;
  };

  return (
    <I18nContext.Provider value={{ locale, setLocale: locale.set, t }}>
      {children}
    </I18nContext.Provider>
  );
}
```

## Best Practices

### Type-Safe Translations

```typescript
// Generate types from translations
type DeepKeys<T, K extends string = ''> = T extends object
  ? {
      [P in keyof T]: P extends string
        ? DeepKeys<T[P], `${K}${K extends '' ? '' : '.'}${P}`>
        : never;
    }[keyof T]
  : K;

type TranslationKeys = DeepKeys<typeof en>;

// Type-safe t function
const t = (key: TranslationKeys, params?: Record<string, any>): string => {
  // ... implementation
};

// Usage - autocomplete and type checking!
t('common.welcome'); // ‚úì
t('nav.home'); // ‚úì
t('invalid.key'); // ‚úó Type error
```

### Extract Reusable Strings

```typescript
// ‚úÖ Keep UI strings in translations
const translations = {
  buttons: {
    save: 'Save',
    cancel: 'Cancel',
    delete: 'Delete'
  }
};

// ‚ùå Don't hardcode strings
<button>Save</button>

// ‚úÖ Use translations
<button>{t('buttons.save')}</button>
```

### Namespace Translations

```typescript
// Group related translations
export const en = {
  pages: {
    home: {
      title: 'Welcome Home',
      subtitle: 'Get started with PhilJS'
    },
    about: {
      title: 'About Us',
      description: 'Learn more about our company'
    }
  },
  components: {
    header: {
      login: 'Log In',
      signup: 'Sign Up'
    }
  }
};
```

### Handle Missing Translations

```typescript
const t = (key: string, params?: Record<string, any>): string => {
  const keys = key.split('.');
  let value: any = translations[locale()];

  for (const k of keys) {
    value = value?.[k];
  }

  // Missing translation - try fallback locale
  if (typeof value !== 'string') {
    value = translations[fallbackLocale];
    for (const k of keys) {
      value = value?.[k];
    }
  }

  // Still missing - log warning and return key
  if (typeof value !== 'string') {
    console.warn(`Missing translation: ${key} for locale ${locale()}`);
    return key;
  }

  return value;
};
```

## Summary

You've learned:

‚úÖ i18n fundamentals and setup
‚úÖ Translation file organization
‚úÖ Using translations in components
‚úÖ Locale switching and persistence
‚úÖ Date, number, and list formatting
‚úÖ Pluralization support
‚úÖ RTL language support
‚úÖ Lazy loading translations
‚úÖ Type-safe translations
‚úÖ Best practices for i18n

i18n enables your app to reach a global audience!

---

**Next:** [Authentication ‚Üí](./authentication.md) Secure your application
