# Repository Pattern

The repository pattern in @philjs/db provides a clean abstraction layer for database operations, offering consistent CRUD operations across all supported providers.

## Overview

The repository pattern:
- Abstracts database access logic
- Provides type-safe CRUD operations
- Works with Prisma, Drizzle, and Supabase
- Includes built-in pagination
- Supports custom primary keys

## Creating a Repository

### Basic Usage

```typescript
import { createRepository } from '@philjs/db';

interface User {
  id: string;
  name: string;
  email: string;
  status: 'active' | 'inactive';
  createdAt: Date;
}

// Create repository
const userRepository = createRepository<User>(db, 'users');

// Use CRUD operations
const user = await userRepository.create({
  name: 'John Doe',
  email: 'john@example.com',
  status: 'active',
});
```

### With Options

```typescript
import { createRepository } from '@philjs/db';
import { usersSchema } from './schema';

const userRepository = createRepository<User>(db, 'users', {
  // Required for Drizzle
  schema: { users: usersSchema },

  // Custom primary key (default: 'id')
  primaryKey: 'userId',
});
```

## CRUD Operations

### Create

Create a new record:

```typescript
const user = await userRepository.create({
  name: 'John Doe',
  email: 'john@example.com',
  status: 'active',
});

console.log('Created:', user.id);
```

The `id` field is automatically generated by the database.

### Find by ID

Find a single record by primary key:

```typescript
const user = await userRepository.findById('123');

if (user) {
  console.log('Found:', user.name);
} else {
  console.log('User not found');
}
```

### Find One

Find the first matching record:

```typescript
const user = await userRepository.findOne({
  email: 'john@example.com',
});

if (user) {
  console.log('Found by email:', user.name);
}
```

### Find Many

Find all matching records:

```typescript
const activeUsers = await userRepository.findMany({
  status: 'active',
});

console.log(`Found ${activeUsers.length} active users`);
```

### Find All (Paginated)

Get all records with pagination:

```typescript
const result = await userRepository.findAll({
  page: 1,
  perPage: 20,
  where: { status: 'active' },
  orderBy: { createdAt: 'desc' },
});

console.log('Users:', result.data);
console.log('Total:', result.meta.total);
console.log('Pages:', result.meta.totalPages);
console.log('Has next:', result.meta.hasNextPage);
```

### Update

Update a record by ID:

```typescript
const updated = await userRepository.update('123', {
  name: 'Jane Doe',
  status: 'inactive',
});

console.log('Updated:', updated.name);
```

### Delete

Delete a record by ID:

```typescript
await userRepository.delete('123');
console.log('User deleted');
```

### Count

Count matching records:

```typescript
const activeCount = await userRepository.count({
  status: 'active',
});

console.log(`${activeCount} active users`);

// Count all
const totalCount = await userRepository.count();
```

## Pagination

### PaginatedResult Structure

```typescript
interface PaginatedResult<T> {
  data: T[];
  meta: {
    total: number;       // Total records matching query
    page: number;        // Current page (1-indexed)
    perPage: number;     // Records per page
    totalPages: number;  // Total number of pages
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };
}
```

### Using Pagination

```typescript
// First page
const page1 = await userRepository.findAll({
  page: 1,
  perPage: 10,
});

// With filters
const filtered = await userRepository.findAll({
  page: 1,
  perPage: 10,
  where: { status: 'active' },
  orderBy: { name: 'asc' },
});

// Navigation
if (filtered.meta.hasNextPage) {
  const nextPage = await userRepository.findAll({
    page: filtered.meta.page + 1,
    perPage: 10,
    where: { status: 'active' },
  });
}
```

### Standalone Pagination

Use the `paginate` function directly:

```typescript
import { paginate } from '@philjs/db';

const result = await paginate<User>(db, 'users', {
  page: 2,
  perPage: 25,
  where: { role: 'admin' },
  orderBy: { createdAt: 'desc' },
});
```

## Soft Delete

### Using Soft Delete Helpers

```typescript
import { softDelete, restore } from '@philjs/db';

// Soft delete (sets deletedAt timestamp)
await softDelete(db, 'users', '123');

// Restore soft deleted record
await restore(db, 'users', '123');
```

### Custom Soft Delete Implementation

```typescript
interface SoftDeletableUser extends User {
  deletedAt: Date | null;
}

const userRepository = createRepository<SoftDeletableUser>(db, 'users');

// Soft delete
async function softDeleteUser(id: string) {
  await userRepository.update(id, {
    deletedAt: new Date(),
  });
}

// Find active (not deleted)
async function findActiveUsers() {
  return userRepository.findMany({
    deletedAt: null,
  });
}

// Restore
async function restoreUser(id: string) {
  await userRepository.update(id, {
    deletedAt: null,
  });
}
```

## Health Check

Monitor database connectivity:

```typescript
import { healthCheck } from '@philjs/db';

const status = await healthCheck(db);

console.log('Healthy:', status.healthy);
console.log('Latency:', status.latency, 'ms');

if (!status.healthy) {
  console.error('Database connection failed!');
  // Trigger alert, restart, etc.
}
```

## Provider-Specific Behavior

### Prisma

```typescript
// Prisma uses model names (usually singular)
const userRepository = createRepository<User>(prisma, 'user');

// Maps to:
// prisma.user.findMany()
// prisma.user.findUnique()
// prisma.user.create()
// prisma.user.update()
// prisma.user.delete()
// prisma.user.count()
```

### Drizzle

```typescript
import { usersTable } from './schema';

// Drizzle requires schema
const userRepository = createRepository<User>(drizzle, 'users', {
  schema: { users: usersTable },
});

// Maps to:
// db.select().from(users)
// db.insert(users).values()
// db.update(users).set()
// db.delete(users)
```

### Supabase

```typescript
// Supabase uses table names
const userRepository = createRepository<User>(supabase, 'users');

// Maps to:
// supabase.from('users').select()
// supabase.from('users').insert()
// supabase.from('users').update()
// supabase.from('users').delete()
```

## Custom Repositories

### Extending Base Repository

```typescript
interface UserRepository extends Repository<User> {
  findByEmail(email: string): Promise<User | null>;
  findActive(): Promise<User[]>;
  deactivate(id: string): Promise<User>;
}

function createUserRepository(db: any): UserRepository {
  const base = createRepository<User>(db, 'users');

  return {
    ...base,

    async findByEmail(email: string) {
      return base.findOne({ email });
    },

    async findActive() {
      return base.findMany({ status: 'active' });
    },

    async deactivate(id: string) {
      return base.update(id, { status: 'inactive' });
    },
  };
}

// Usage
const users = createUserRepository(db);
const user = await users.findByEmail('john@example.com');
const activeUsers = await users.findActive();
```

### Repository Factory

```typescript
import { createRepository, Repository } from '@philjs/db';

interface EntityBase {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

interface ExtendedRepository<T extends EntityBase> extends Repository<T> {
  findRecent(limit?: number): Promise<T[]>;
  touch(id: string): Promise<T>;
}

function createExtendedRepository<T extends EntityBase>(
  db: any,
  tableName: string,
  options?: { schema?: any }
): ExtendedRepository<T> {
  const base = createRepository<T>(db, tableName, options);

  return {
    ...base,

    async findRecent(limit = 10) {
      const result = await base.findAll({
        page: 1,
        perPage: limit,
        orderBy: { createdAt: 'desc' },
      });
      return result.data;
    },

    async touch(id: string) {
      return base.update(id, {
        updatedAt: new Date(),
      } as Partial<T>);
    },
  };
}

// Usage
const posts = createExtendedRepository<Post>(db, 'posts');
const recentPosts = await posts.findRecent(5);
```

## Using with Transactions

```typescript
import { transaction, createRepository } from '@philjs/db';

async function createUserWithProfile(userData, profileData) {
  return transaction(db, async (tx) => {
    // Create repository with transaction client
    const users = createRepository<User>(tx.client, 'users');
    const profiles = createRepository<Profile>(tx.client, 'profiles');

    const user = await users.create(userData);
    const profile = await profiles.create({
      ...profileData,
      userId: user.id,
    });

    return { user, profile };
  });
}
```

## Repository Interface

```typescript
interface Repository<T> {
  /**
   * Find all records with pagination
   */
  findAll(options?: PaginationOptions): Promise<PaginatedResult<T>>;

  /**
   * Find record by primary key
   */
  findById(id: string | number): Promise<T | null>;

  /**
   * Find first matching record
   */
  findOne(where: Partial<T>): Promise<T | null>;

  /**
   * Find all matching records
   */
  findMany(where: Partial<T>): Promise<T[]>;

  /**
   * Create a new record
   */
  create(data: Omit<T, 'id'>): Promise<T>;

  /**
   * Update a record by ID
   */
  update(id: string | number, data: Partial<T>): Promise<T>;

  /**
   * Delete a record by ID
   */
  delete(id: string | number): Promise<void>;

  /**
   * Count matching records
   */
  count(where?: Partial<T>): Promise<number>;
}

interface PaginationOptions {
  page?: number;
  perPage?: number;
  where?: Record<string, unknown>;
  orderBy?: Record<string, 'asc' | 'desc'>;
}
```

## Best Practices

### 1. One Repository Per Entity

```typescript
// Good - separate repositories
const userRepository = createRepository<User>(db, 'users');
const postRepository = createRepository<Post>(db, 'posts');
const commentRepository = createRepository<Comment>(db, 'comments');

// Bad - mixing entities
const dataRepository = {
  users: createRepository<User>(db, 'users'),
  posts: createRepository<Post>(db, 'posts'),
};
```

### 2. Use Type-Safe Entities

```typescript
// Define strict types
interface User {
  id: string;
  name: string;
  email: string;
  status: 'active' | 'inactive' | 'pending';
  createdAt: Date;
  updatedAt: Date;
}

// Repository is fully typed
const users = createRepository<User>(db, 'users');

// TypeScript catches errors
await users.create({
  name: 'John',
  email: 'john@example.com',
  status: 'unknown',  // Error: Type '"unknown"' is not assignable
});
```

### 3. Handle Errors Gracefully

```typescript
async function getUserById(id: string): Promise<User> {
  const user = await userRepository.findById(id);

  if (!user) {
    throw new NotFoundError(`User ${id} not found`);
  }

  return user;
}

async function createUser(data: CreateUserInput): Promise<User> {
  try {
    return await userRepository.create(data);
  } catch (error) {
    if (isUniqueConstraintError(error)) {
      throw new ConflictError('Email already exists');
    }
    throw error;
  }
}
```

### 4. Initialize Repositories at Module Level

```typescript
// repositories/index.ts
import { createRepository } from '@philjs/db';
import { db } from '../lib/db';

export const userRepository = createRepository<User>(db, 'users');
export const postRepository = createRepository<Post>(db, 'posts');
export const commentRepository = createRepository<Comment>(db, 'comments');

// Usage
import { userRepository } from './repositories';

const user = await userRepository.findById('123');
```

## Next Steps

- [Queries](./queries.md) - Advanced queries
- [Transactions](./transactions.md) - Transaction handling
- [Schema](./schema.md) - Schema validation
