import { signal, effect } from '@philjs/core';
import { HomePage } from './pages/HomePage';
import { Sidebar } from './components/Sidebar';
import { TableOfContents } from './components/TableOfContents';
import { SearchModal } from './components/SearchModal';
import { Breadcrumbs } from './components/Breadcrumbs';
import { DocNavigation } from './components/DocNavigation';
import { renderMarkdown } from './lib/markdown-renderer';
import { docsStructure } from './lib/docs-structure';
import './styles/global.css';
import 'highlight.js/styles/github-dark.css';

// Client-side routing
const currentPath = signal(window.location.pathname);

window.addEventListener('popstate', () => {
  currentPath.set(window.location.pathname);
});

function navigate(path: string) {
  window.history.pushState({}, '', path);
  currentPath.set(path);
  window.scrollTo(0, 0);
}

export function App() {
  // Render all routes, show/hide with display
  return (
    <>
      <div style={`display: ${(() => {
        const path = currentPath();
        return (path === '/' || path === '') ? 'block' : 'none';
      })()}`}>
        <HomePage navigate={navigate} />
      </div>

      <div style={`display: ${(() => {
        const path = currentPath();
        return path.startsWith('/docs') ? 'block' : 'none';
      })()}`}>
        <DocsViewer navigate={navigate} path={currentPath()} />
      </div>

      <div style={`display: ${(() => {
        const path = currentPath();
        const isHome = path === '/' || path === '';
        const isDocs = path.startsWith('/docs');
        return (!isHome && !isDocs) ? 'flex' : 'none';
      })()}; min-height: 100vh; align-items: center; justify-content: center; flex-direction: column; gap: 1rem;`}>
        <h1 style="font-size: 4rem; font-weight: 700; color: var(--color-text);">404</h1>
        <p style="font-size: 1.25rem; color: var(--color-text-secondary);">Page not found</p>
        <button
          onClick={() => navigate('/')}
          style="
            padding: 0.75rem 1.5rem;
            background: var(--color-brand);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
          "
          onMouseEnter={(e) => (e.target as HTMLElement).style.transform = 'scale(1.05)'}
          onMouseLeave={(e) => (e.target as HTMLElement).style.transform = 'scale(1)'}
        >
          Go Home
        </button>
      </div>
    </>
  );
}

function DocsViewer({ navigate, path }: { navigate: (path: string) => void; path: string }) {
  const content = signal('Loading...');
  const renderedContent = signal('');
  let articleRef: HTMLElement;

  // Parse the path to get section and file
  const pathParts = path.split('/').filter(Boolean);
  const section = pathParts[1] || 'getting-started';
  const file = pathParts[2] || getFirstFileForSection(section);

  // Load markdown content
  effect(() => {
    const markdownPath = `/md-files/${section}/${file}.md`;
    fetch(markdownPath)
      .then(res => {
        if (!res.ok) throw new Error('Not found');
        return res.text();
      })
      .then(text => {
        content.set(text);
        const html = renderMarkdown(text);
        renderedContent.set(html);
      })
      .catch(() => {
        content.set('# Document not found\n\nThe requested documentation could not be loaded.');
        renderedContent.set(renderMarkdown('# Document not found\n\nThe requested documentation could not be loaded.'));
      });
  });

  // Update article innerHTML when content changes
  effect(() => {
    if (articleRef) {
      articleRef.innerHTML = renderedContent();
    }
  });

  return (
    <div style="padding: 2rem; max-width: 900px; margin: 0 auto;">
      <article
        ref={(el: HTMLElement) => articleRef = el}
        class="prose"
        style="max-width: 100%;"
      />
    </div>
  );
}

// Helper function to get first file for a section
function getFirstFileForSection(sectionPath: string): string {
  const section = docsStructure.find(s => s.path === sectionPath);
  return section?.items[0]?.file || 'overview';
}
