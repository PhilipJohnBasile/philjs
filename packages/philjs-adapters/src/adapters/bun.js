/**
 * PhilJS Bun Adapter
 *
 * Production-ready deployment adapter for Bun with:
 * - Native Bun.serve() integration
 * - Fast file serving
 * - SQLite support
 * - WebSocket support
 * - Hot reload
 *
 * @module philjs-adapters/adapters/bun
 */
import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { createBuildManifest, copyStaticAssets, MIME_TYPES } from '../utils/build.js';
import { loadEnvFile } from '../utils/env.js';
/**
 * Create a Bun deployment adapter
 *
 * @example
 * ```typescript
 * import { bunAdapter } from 'philjs-adapters/adapters/bun';
 *
 * export default defineConfig({
 *   adapter: bunAdapter({
 *     port: 3000,
 *     compression: true,
 *     websocket: {
 *       enabled: true,
 *       maxPayloadLength: 16 * 1024 * 1024,
 *     },
 *     sqlite: './data.db',
 *   }),
 * });
 * ```
 */
export function bunAdapter(config = {}) {
    const { outDir = '.bun', port = 3000, hostname = '0.0.0.0', development = process.env['NODE_ENV'] !== 'production', staticDir = 'public', compression = true, sqlite, websocket, tls, maxRequestBodySize = 128 * 1024 * 1024, // 128MB
    idleTimeout = 10, hotReload = development, generateConfig = true, generateDockerfile = false, optimizations = {}, } = config;
    const sqliteConfig = sqlite
        ? typeof sqlite === 'string'
            ? { path: sqlite }
            : sqlite
        : null;
    return {
        name: 'bun',
        async adapt() {
            console.log('Building for Bun runtime...');
            // Create output directory
            mkdirSync(outDir, { recursive: true });
            // Generate server entry point
            writeFileSync(join(outDir, 'server.ts'), generateServerCode());
            // Generate package.json
            writeFileSync(join(outDir, 'package.json'), JSON.stringify({
                name: 'philjs-bun',
                version: '1.0.0',
                type: 'module',
                scripts: {
                    start: 'bun run server.ts',
                    dev: 'bun --hot run server.ts',
                },
                dependencies: {
                    '@philjs/ssr': 'latest',
                },
            }, null, 2));
            // Generate bunfig.toml
            if (generateConfig) {
                writeFileSync(join(outDir, 'bunfig.toml'), generateBunfigToml());
            }
            // Generate Dockerfile
            if (generateDockerfile) {
                writeFileSync(join(outDir, 'Dockerfile'), generateDockerfileContent());
            }
            // Copy static assets
            await copyStaticAssets(staticDir, join(outDir, 'public'));
            // Generate build manifest
            const manifest = await createBuildManifest({
                adapter: 'bun',
                outputDir: outDir,
                routes: [],
            });
            writeFileSync(join(outDir, 'manifest.json'), JSON.stringify(manifest, null, 2));
            console.log(`Bun build complete: ${outDir}`);
        },
        getHandler() {
            return async (request) => {
                const url = new URL(request.url);
                const requestContext = {
                    url,
                    method: request.method,
                    headers: request.headers,
                    body: request.body,
                    params: {},
                    platform: {
                        name: 'bun',
                        development,
                        sqlite: sqliteConfig,
                    },
                };
                const { handleRequest } = await import('@philjs/ssr');
                return handleRequest(requestContext);
            };
        },
    };
    /**
     * Generate Bun server code
     */
    function generateServerCode() {
        return `// PhilJS Bun Server
// Generated by PhilJS Adapters

import { handleRequest } from '@philjs/ssr';

const PORT = parseInt(Bun.env.PORT || '${port}');
const HOSTNAME = Bun.env.HOSTNAME || '${hostname}';
const DEVELOPMENT = ${development};

// MIME types
const MIME_TYPES: Record<string, string> = ${JSON.stringify(MIME_TYPES, null, 2)};

${sqliteConfig ? `
// SQLite database
const db = new Bun.SQLiteDatabase('${sqliteConfig.path}', {
  ${sqliteConfig.create !== false ? 'create: true,' : ''}
  ${sqliteConfig.readonly ? 'readonly: true,' : ''}
});

${sqliteConfig.wal !== false ? `db.exec('PRAGMA journal_mode = WAL');` : ''}
` : ''}

/**
 * Try to serve a static file using Bun's native file serving
 */
async function tryServeStatic(pathname: string): Promise<Response | null> {
  const staticDirs = ['./public', './.philjs/prerendered'];

  for (const dir of staticDirs) {
    const filePath = \`\${dir}\${pathname}\`;
    const file = Bun.file(filePath);

    if (await file.exists()) {
      const ext = pathname.substring(pathname.lastIndexOf('.'));
      const contentType = MIME_TYPES[ext] || 'application/octet-stream';

      const headers: HeadersInit = {
        'Content-Type': contentType,
        'Cache-Control': DEVELOPMENT
          ? 'no-cache'
          : 'public, max-age=31536000, immutable',
      };

      ${compression ? `
      // Bun automatically handles compression for text content
      ` : ''}

      return new Response(file, { headers });
    }
  }

  return null;
}

${websocket?.enabled ? `
// WebSocket handlers
const wsHandlers = new Map<string, (ws: any, data: any) => void>();

export function onWebSocketMessage(callback: (ws: any, message: string | ArrayBuffer) => void) {
  wsHandlers.set('message', callback);
}

export function onWebSocketOpen(callback: (ws: any) => void) {
  wsHandlers.set('open', callback);
}

export function onWebSocketClose(callback: (ws: any, code: number, reason: string) => void) {
  wsHandlers.set('close', callback);
}
` : ''}

/**
 * Main fetch handler
 */
async function fetch(request: Request, server: any): Promise<Response> {
  const url = new URL(request.url);

  ${websocket?.enabled ? `
  // Handle WebSocket upgrade
  if (request.headers.get('upgrade') === 'websocket') {
    const success = server.upgrade(request, {
      data: { url: request.url },
    });
    if (success) {
      return new Response(null, { status: 101 });
    }
    return new Response('WebSocket upgrade failed', { status: 400 });
  }
  ` : ''}

  // Try to serve static files first
  const staticResponse = await tryServeStatic(url.pathname);
  if (staticResponse) {
    return staticResponse;
  }

  // Handle index.html for directory requests
  if (url.pathname.endsWith('/')) {
    const indexResponse = await tryServeStatic(url.pathname + 'index.html');
    if (indexResponse) {
      return indexResponse;
    }
  }

  try {
    const context = {
      url,
      method: request.method,
      headers: request.headers,
      body: request.body,
      params: {},
      platform: {
        name: 'bun',
        server,
        development: DEVELOPMENT,
        ${sqliteConfig ? 'db,' : ''}
      },
    };

    const response = await handleRequest(context);

    ${compression ? `
    // Apply compression if enabled and content is compressible
    const contentType = response.headers.get('Content-Type') || '';
    if (contentType.includes('text/') || contentType.includes('application/json')) {
      const body = await response.text();
      const compressed = Bun.gzipSync(new TextEncoder().encode(body));

      return new Response(compressed, {
        status: response.status,
        headers: {
          ...Object.fromEntries(response.headers.entries()),
          'Content-Encoding': 'gzip',
        },
      });
    }
    ` : ''}

    return response;
  } catch (error) {
    console.error('PhilJS request error:', error);

    if (DEVELOPMENT) {
      return new Response(
        \`<html>
          <head><title>Error</title></head>
          <body style="font-family: system-ui; padding: 2rem;">
            <h1>Server Error</h1>
            <pre style="background: #f0f0f0; padding: 1rem; overflow: auto;">\${
              error instanceof Error ? error.stack : String(error)
            }</pre>
          </body>
        </html>\`,
        {
          status: 500,
          headers: { 'Content-Type': 'text/html' },
        }
      );
    }

    return new Response('Internal Server Error', { status: 500 });
  }
}

// Server configuration
const serverConfig: any = {
  port: PORT,
  hostname: HOSTNAME,
  development: DEVELOPMENT,
  fetch,
  maxRequestBodySize: ${maxRequestBodySize},
  idleTimeout: ${idleTimeout},
};

${tls ? `
// TLS configuration
serverConfig.tls = {
  key: Bun.file('${tls.key}'),
  cert: Bun.file('${tls.cert}'),
  ${tls.ca ? `ca: Bun.file('${tls.ca}'),` : ''}
  ${tls.passphrase ? `passphrase: '${tls.passphrase}',` : ''}
};
` : ''}

${websocket?.enabled ? `
// WebSocket configuration
serverConfig.websocket = {
  message: (ws: any, message: string | ArrayBuffer) => {
    const handler = wsHandlers.get('message');
    if (handler) handler(ws, message);
  },
  open: (ws: any) => {
    const handler = wsHandlers.get('open');
    if (handler) handler(ws, null);
  },
  close: (ws: any, code: number, reason: string) => {
    const handler = wsHandlers.get('close');
    if (handler) handler(ws, { code, reason });
  },
  drain: (ws: any) => {
    const handler = wsHandlers.get('drain');
    if (handler) handler(ws, null);
  },
  maxPayloadLength: ${websocket.maxPayloadLength || 16 * 1024 * 1024},
  idleTimeout: ${websocket.idleTimeout || 120},
  backpressureLimit: ${websocket.backpressureLimit || 1024 * 1024},
  closeOnBackpressureLimit: ${websocket.closeOnBackpressureLimit || false},
  ${websocket.perMessageDeflate !== false ? 'perMessageDeflate: true,' : ''}
};
` : ''}

// Start server
const server = Bun.serve(serverConfig);

const protocol = ${tls ? "'https'" : "'http'"};
console.log(\`PhilJS running on \${protocol}://\${HOSTNAME}:\${PORT}\`);

${hotReload && development ? `
if (DEVELOPMENT) {
  console.log('Hot reload enabled');
}
` : ''}

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('Shutting down...');
  server.stop();
  ${sqliteConfig ? 'db.close();' : ''}
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('Shutting down...');
  server.stop();
  ${sqliteConfig ? 'db.close();' : ''}
  process.exit(0);
});

export default server;
`;
    }
    /**
     * Generate bunfig.toml
     */
    function generateBunfigToml() {
        return `# Bun Configuration
# Generated by PhilJS Adapters

[install]
# Use exact versions
exact = true

# Lockfile
save-lockfile = true

[run]
# Silent mode
silent = false

${hotReload ? `[watch]
# Watch directories
include = ["src", "public"]
exclude = ["node_modules", ".git"]
` : ''}

${optimizations.nativeFetch !== false ? `[fetch]
# Use native fetch
native = true
` : ''}

[define]
# Environment variables
"process.env.NODE_ENV" = '"production"'
`;
    }
    /**
     * Generate Dockerfile for Bun
     */
    function generateDockerfileContent() {
        return `# PhilJS Bun Dockerfile
# Generated by PhilJS Adapters

FROM oven/bun:1 AS base
WORKDIR /app

# Install dependencies
FROM base AS deps
COPY package.json bun.lockb* ./
RUN bun install --frozen-lockfile

# Build stage
FROM base AS build
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN bun run build

# Production stage
FROM base AS runner
ENV NODE_ENV=production
ENV PORT=${port}

# Create non-root user
RUN addgroup --system --gid 1001 bun
RUN adduser --system --uid 1001 philjs
USER philjs

COPY --from=deps --chown=philjs:bun /app/node_modules ./node_modules
COPY --from=build --chown=philjs:bun /app/server.ts ./
COPY --from=build --chown=philjs:bun /app/public ./public

EXPOSE ${port}

CMD ["bun", "run", "server.ts"]
`;
    }
}
// ============================================================================
// Utility Functions
// ============================================================================
/**
 * Check if running in Bun
 */
export function isBun() {
    return typeof globalThis !== 'undefined' && 'Bun' in globalThis;
}
/**
 * Create Bun SQLite helpers
 */
export function createBunSQLite(path = ':memory:') {
    if (!isBun()) {
        throw new Error('Bun SQLite is only available in Bun runtime');
    }
    const Bun = globalThis.Bun;
    const db = new Bun.SQLiteDatabase(path);
    return {
        db,
        query(sql, params) {
            const stmt = db.prepare(sql);
            return params ? stmt.all(...params) : stmt.all();
        },
        run(sql, params) {
            const stmt = db.prepare(sql);
            params ? stmt.run(...params) : stmt.run();
        },
        get(sql, params) {
            const stmt = db.prepare(sql);
            return params ? stmt.get(...params) : stmt.get();
        },
        exec(sql) {
            db.exec(sql);
        },
        transaction(fn) {
            return db.transaction(fn)();
        },
        close() {
            db.close();
        },
    };
}
/**
 * Create Bun file helper
 */
export function bunFile(path) {
    if (!isBun()) {
        throw new Error('Bun file API is only available in Bun runtime');
    }
    const Bun = globalThis.Bun;
    return Bun.file(path);
}
/**
 * Bun password hashing
 */
export async function bunHash(password) {
    if (!isBun()) {
        throw new Error('Bun hash is only available in Bun runtime');
    }
    const Bun = globalThis.Bun;
    return Bun.password.hash(password);
}
/**
 * Bun password verification
 */
export async function bunVerify(password, hash) {
    if (!isBun()) {
        throw new Error('Bun verify is only available in Bun runtime');
    }
    const Bun = globalThis.Bun;
    return Bun.password.verify(password, hash);
}
/**
 * Create a Bun-native handler for use with Bun.serve()
 */
export function createBunHandler(config = {}) {
    const adapter = bunAdapter(config);
    return adapter.getHandler();
}
export default bunAdapter;
//# sourceMappingURL=bun.js.map