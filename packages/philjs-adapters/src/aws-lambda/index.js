/**
 * PhilJS AWS Lambda Adapter
 *
 * Full-featured AWS deployment with:
 * - Lambda function handler
 * - API Gateway integration (REST & HTTP APIs)
 * - CloudFront integration
 * - S3 static assets
 * - Lambda@Edge support
 * - ALB (Application Load Balancer) support
 */
import { writeFileSync, mkdirSync, cpSync, existsSync } from 'fs';
import { join } from 'path';
export function awsLambdaAdapter(config = {}) {
    const { outDir = '.aws', static: staticConfig, region = 'us-east-1', runtime = 'nodejs20.x', memorySize = 1024, timeout = 30, handler = 'index.handler', integration = 'api-gateway', apiGateway, cloudfront, s3, layers = [], environment = {}, vpc, roleArn, generateSAM = true, generateServerless = false, generateTerraform = false, } = config;
    return {
        name: 'aws-lambda',
        serverless: true,
        functionConfig: {
            memory: memorySize,
            timeout,
            runtime,
        },
        async adapt() {
            console.log('Building for AWS Lambda...');
            // Create output structure
            mkdirSync(outDir, { recursive: true });
            mkdirSync(join(outDir, 'lambda'), { recursive: true });
            // Generate Lambda handler
            writeFileSync(join(outDir, 'lambda', 'index.js'), generateLambdaHandler());
            // Generate package.json for Lambda
            writeFileSync(join(outDir, 'lambda', 'package.json'), JSON.stringify({
                name: 'philjs-lambda',
                version: '1.0.0',
                type: 'module',
                dependencies: {
                    '@philjs/ssr': 'latest',
                },
            }, null, 2));
            // Generate infrastructure as code templates
            if (generateSAM) {
                writeFileSync(join(outDir, 'template.yaml'), generateSAMTemplate());
            }
            if (generateServerless) {
                writeFileSync(join(outDir, 'serverless.yml'), generateServerlessConfig());
            }
            if (generateTerraform) {
                writeFileSync(join(outDir, 'main.tf'), generateTerraformConfig());
            }
            // Generate deployment scripts
            writeFileSync(join(outDir, 'deploy.sh'), generateDeployScript());
            // Copy static assets to S3 preparation directory
            if (s3) {
                mkdirSync(join(outDir, 's3'), { recursive: true });
                const staticDir = staticConfig?.assets || 'public';
                if (existsSync(staticDir)) {
                    cpSync(staticDir, join(outDir, 's3'), { recursive: true });
                }
            }
            // Copy prerendered pages
            if (existsSync('.philjs/prerendered')) {
                cpSync('.philjs/prerendered', join(outDir, 's3'), { recursive: true });
            }
            // Generate TypeScript types
            writeFileSync(join(outDir, 'types.d.ts'), generateTypeScriptTypes());
            console.log(`AWS Lambda build complete: ${outDir}`);
        },
        getHandler() {
            return async (request, context) => {
                const url = new URL(request.url);
                const requestContext = {
                    url,
                    method: request.method,
                    headers: request.headers,
                    body: request.body,
                    params: {},
                    platform: {
                        name: 'aws-lambda',
                        edge: false,
                        context,
                        region,
                        s3: s3 ? createS3Helpers() : undefined,
                    },
                };
                const { handleRequest } = await import('@philjs/ssr');
                return handleRequest(requestContext);
            };
        },
    };
    function generateLambdaHandler() {
        switch (integration) {
            case 'api-gateway':
                return generateAPIGatewayHandler();
            case 'http-api':
                return generateHTTPAPIHandler();
            case 'alb':
                return generateALBHandler();
            case 'lambda-edge':
                return generateLambdaEdgeHandler();
            case 'cloudfront':
                return generateCloudFrontHandler();
            default:
                return generateAPIGatewayHandler();
        }
    }
    function generateAPIGatewayHandler() {
        return `// PhilJS AWS Lambda Handler (API Gateway)
// Generated by PhilJS Adapters

export const handler = async (event, context) => {
  const { handleRequest } = await import('@philjs/ssr');

  // Construct URL from API Gateway event
  const protocol = event.headers['X-Forwarded-Proto'] || 'https';
  const host = event.headers.Host || event.headers.host;
  const path = event.requestContext?.http?.path || event.path;
  const queryString = event.rawQueryString || '';
  const url = new URL(\`\${protocol}://\${host}\${path}\${queryString ? '?' + queryString : ''}\`);

  // Convert API Gateway headers to Web API Headers
  const headers = new Headers();
  for (const [key, value] of Object.entries(event.headers || {})) {
    if (value) headers.append(key, value);
  }

  // Create request context
  const requestContext = {
    url,
    method: event.requestContext?.http?.method || event.httpMethod,
    headers,
    body: event.body ? new ReadableStream({
      start(controller) {
        const body = event.isBase64Encoded
          ? Buffer.from(event.body, 'base64').toString()
          : event.body;
        controller.enqueue(new TextEncoder().encode(body));
        controller.close();
      }
    }) : null,
    params: event.pathParameters || {},
    platform: {
      name: 'aws-lambda',
      edge: false,
      context,
      event,
      region: '${region}',
    },
  };

  try {
    const response = await handleRequest(requestContext);

    // Convert Web API Response to API Gateway response
    const responseHeaders = {};
    response.headers.forEach((value, key) => {
      responseHeaders[key] = value;
    });

    let body = '';
    if (response.body) {
      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        body += decoder.decode(value, { stream: true });
      }
    }

    return {
      statusCode: response.status,
      headers: responseHeaders,
      body,
      isBase64Encoded: false,
    };
  } catch (error) {
    console.error('PhilJS request error:', error);
    return {
      statusCode: 500,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        error: 'Internal Server Error',
        message: error.message,
      }),
    };
  }
};
`;
    }
    function generateHTTPAPIHandler() {
        return `// PhilJS AWS Lambda Handler (HTTP API)
// Generated by PhilJS Adapters

export const handler = async (event, context) => {
  const { handleRequest } = await import('@philjs/ssr');

  const url = new URL(event.rawPath + (event.rawQueryString ? '?' + event.rawQueryString : ''),
    \`https://\${event.requestContext.domainName}\`);

  const headers = new Headers();
  for (const [key, value] of Object.entries(event.headers || {})) {
    if (value) headers.append(key, value);
  }

  const requestContext = {
    url,
    method: event.requestContext.http.method,
    headers,
    body: event.body ? new ReadableStream({
      start(controller) {
        const body = event.isBase64Encoded
          ? Buffer.from(event.body, 'base64').toString()
          : event.body;
        controller.enqueue(new TextEncoder().encode(body));
        controller.close();
      }
    }) : null,
    params: event.pathParameters || {},
    platform: {
      name: 'aws-lambda',
      edge: false,
      context,
      event,
      region: '${region}',
    },
  };

  try {
    const response = await handleRequest(requestContext);

    const responseHeaders = {};
    response.headers.forEach((value, key) => {
      responseHeaders[key] = value;
    });

    let body = '';
    if (response.body) {
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        body += decoder.decode(value, { stream: true });
      }
    }

    return {
      statusCode: response.status,
      headers: responseHeaders,
      body,
    };
  } catch (error) {
    console.error('PhilJS request error:', error);
    return {
      statusCode: 500,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        error: 'Internal Server Error',
        message: error.message,
      }),
    };
  }
};
`;
    }
    function generateALBHandler() {
        return `// PhilJS AWS Lambda Handler (Application Load Balancer)
// Generated by PhilJS Adapters

export const handler = async (event, context) => {
  const { handleRequest } = await import('@philjs/ssr');

  const protocol = event.headers['x-forwarded-proto'] || 'https';
  const host = event.headers.host;
  const path = event.path;
  const queryString = event.queryStringParameters
    ? new URLSearchParams(event.queryStringParameters).toString()
    : '';
  const url = new URL(\`\${protocol}://\${host}\${path}\${queryString ? '?' + queryString : ''}\`);

  const headers = new Headers();
  for (const [key, value] of Object.entries(event.headers || {})) {
    if (value) headers.append(key, value);
  }

  const requestContext = {
    url,
    method: event.httpMethod,
    headers,
    body: event.body ? new ReadableStream({
      start(controller) {
        const body = event.isBase64Encoded
          ? Buffer.from(event.body, 'base64').toString()
          : event.body;
        controller.enqueue(new TextEncoder().encode(body));
        controller.close();
      }
    }) : null,
    params: {},
    platform: {
      name: 'aws-lambda',
      edge: false,
      context,
      event,
      region: '${region}',
    },
  };

  try {
    const response = await handleRequest(requestContext);

    const responseHeaders = {};
    response.headers.forEach((value, key) => {
      responseHeaders[key] = value;
    });

    let body = '';
    if (response.body) {
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        body += decoder.decode(value, { stream: true });
      }
    }

    return {
      statusCode: response.status,
      statusDescription: \`\${response.status} \${response.statusText || 'OK'}\`,
      headers: responseHeaders,
      body,
      isBase64Encoded: false,
    };
  } catch (error) {
    console.error('PhilJS request error:', error);
    return {
      statusCode: 500,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        error: 'Internal Server Error',
        message: error.message,
      }),
    };
  }
};
`;
    }
    function generateLambdaEdgeHandler() {
        return `// PhilJS AWS Lambda@Edge Handler
// Generated by PhilJS Adapters

export const handler = async (event) => {
  const request = event.Records[0].cf.request;
  const { handleRequest } = await import('@philjs/ssr');

  const protocol = request.headers['cloudfront-forwarded-proto']
    ? request.headers['cloudfront-forwarded-proto'][0].value
    : 'https';
  const host = request.headers.host[0].value;
  const path = request.uri;
  const queryString = request.querystring;
  const url = new URL(\`\${protocol}://\${host}\${path}\${queryString ? '?' + queryString : ''}\`);

  const headers = new Headers();
  for (const [key, values] of Object.entries(request.headers)) {
    for (const { value } of values) {
      headers.append(key, value);
    }
  }

  const requestContext = {
    url,
    method: request.method,
    headers,
    body: request.body?.data ? new ReadableStream({
      start(controller) {
        const body = request.body.encoding === 'base64'
          ? Buffer.from(request.body.data, 'base64').toString()
          : request.body.data;
        controller.enqueue(new TextEncoder().encode(body));
        controller.close();
      }
    }) : null,
    params: {},
    platform: {
      name: 'aws-lambda-edge',
      edge: true,
      event,
    },
  };

  try {
    const response = await handleRequest(requestContext);

    const responseHeaders = {};
    response.headers.forEach((value, key) => {
      responseHeaders[key.toLowerCase()] = [{ key, value }];
    });

    let body = '';
    if (response.body) {
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        body += decoder.decode(value, { stream: true });
      }
    }

    return {
      status: response.status.toString(),
      statusDescription: response.statusText || 'OK',
      headers: responseHeaders,
      body,
    };
  } catch (error) {
    console.error('PhilJS request error:', error);
    return {
      status: '500',
      statusDescription: 'Internal Server Error',
      headers: {
        'content-type': [{ key: 'Content-Type', value: 'application/json' }],
      },
      body: JSON.stringify({
        error: 'Internal Server Error',
        message: error.message,
      }),
    };
  }
};
`;
    }
    function generateCloudFrontHandler() {
        return `// PhilJS AWS CloudFront Functions Handler
// Generated by PhilJS Adapters

function handler(event) {
  var request = event.request;

  // CloudFront Functions are very limited - mainly used for URL rewrites
  // For SSR, use Lambda@Edge instead

  // Simple SPA rewrite
  if (!request.uri.includes('.')) {
    request.uri = '/index.html';
  }

  return request;
}
`;
    }
    function generateSAMTemplate() {
        return `AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: PhilJS Application deployed with AWS SAM

Globals:
  Function:
    Timeout: ${timeout}
    MemorySize: ${memorySize}
    Runtime: ${runtime}
    ${layers.length > 0 ? `Layers:\n${layers.map(l => `      - ${l}`).join('\n')}` : ''}
    ${Object.keys(environment).length > 0 ? `Environment:\n      Variables:\n${Object.entries(environment).map(([k, v]) => `        ${k}: ${v}`).join('\n')}` : ''}

Resources:
  PhilJSFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/
      Handler: ${handler}
      ${vpc ? `VpcConfig:\n        SubnetIds:\n${vpc.subnetIds.map(id => `          - ${id}`).join('\n')}\n        SecurityGroupIds:\n${vpc.securityGroupIds.map(id => `          - ${id}`).join('\n')}` : ''}
      ${roleArn ? `Role: ${roleArn}` : ''}
      Events:
        ApiEvent:
          Type: ${apiGateway?.type === 'HTTP' ? 'HttpApi' : 'Api'}
          Properties:
            Path: /{proxy+}
            Method: ANY
            ${apiGateway?.cors ? 'Cors:\n              AllowOrigin: "*"\n              AllowMethods: "*"\n              AllowHeaders: "*"' : ''}

${s3 ? `  StaticAssetsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: ${s3.bucket}
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html

  StaticAssetsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref StaticAssetsBucket
      PolicyDocument:
        Statement:
          - Sid: PublicReadGetObject
            Effect: Allow
            Principal: '*'
            Action: s3:GetObject
            Resource: !Sub '\${StaticAssetsBucket.Arn}/*'` : ''}

${cloudfront ? `  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt StaticAssetsBucket.DomainName
            S3OriginConfig:
              OriginAccessIdentity: ''
          - Id: APIOrigin
            DomainName: !Sub '\${ServerlessRestApi}.execute-api.\${AWS::Region}.amazonaws.com'
            CustomOriginConfig:
              HTTPSPort: 443
              OriginProtocolPolicy: https-only
        DefaultCacheBehavior:
          TargetOriginId: APIOrigin
          ViewerProtocolPolicy: redirect-to-https
          ForwardedValues:
            QueryString: true
            Headers:
              - '*'
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
            - PUT
            - POST
            - PATCH
            - DELETE
        CacheBehaviors:
          - PathPattern: /static/*
            TargetOriginId: S3Origin
            ViewerProtocolPolicy: redirect-to-https
            ForwardedValues:
              QueryString: false
            Compress: true
            MinTTL: 31536000` : ''}

Outputs:
  ApiUrl:
    Description: API Gateway endpoint URL
    Value: !Sub 'https://\${ServerlessRestApi}.execute-api.\${AWS::Region}.amazonaws.com/${apiGateway?.stageName || 'Prod'}/'

  FunctionArn:
    Description: Lambda Function ARN
    Value: !GetAtt PhilJSFunction.Arn

${s3 ? `  S3BucketName:
    Description: S3 bucket for static assets
    Value: !Ref StaticAssetsBucket` : ''}

${cloudfront ? `  CloudFrontUrl:
    Description: CloudFront distribution URL
    Value: !GetAtt CloudFrontDistribution.DomainName` : ''}
`;
    }
    function generateServerlessConfig() {
        return `service: philjs-app

provider:
  name: aws
  runtime: ${runtime}
  region: ${region}
  memorySize: ${memorySize}
  timeout: ${timeout}
  ${vpc ? `vpc:\n    securityGroupIds:\n${vpc.securityGroupIds.map(id => `      - ${id}`).join('\n')}\n    subnetIds:\n${vpc.subnetIds.map(id => `      - ${id}`).join('\n')}` : ''}
  ${Object.keys(environment).length > 0 ? `environment:\n${Object.entries(environment).map(([k, v]) => `    ${k}: ${v}`).join('\n')}` : ''}

functions:
  app:
    handler: index.handler
    events:
      - httpApi:
          path: /{proxy+}
          method: ANY
    ${layers.length > 0 ? `layers:\n${layers.map(l => `      - ${l}`).join('\n')}` : ''}

${s3 ? `resources:
  Resources:
    StaticAssetsBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${s3.bucket}
        PublicAccessBlockConfiguration:
          BlockPublicAcls: false
        WebsiteConfiguration:
          IndexDocument: index.html

plugins:
  - serverless-s3-sync

custom:
  s3Sync:
    - bucketName: ${s3.bucket}
      localDir: s3/
      acl: public-read
      defaultContentType: text/html` : ''}
`;
    }
    function generateTerraformConfig() {
        return `# PhilJS AWS Lambda Terraform Configuration

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "${region}"
}

resource "aws_lambda_function" "philjs_app" {
  filename      = "lambda.zip"
  function_name = "philjs-app"
  role          = ${roleArn ? `"${roleArn}"` : 'aws_iam_role.lambda_role.arn'}
  handler       = "${handler}"
  runtime       = "${runtime}"
  timeout       = ${timeout}
  memory_size   = ${memorySize}

  ${layers.length > 0 ? `layers = ${JSON.stringify(layers)}` : ''}

  ${Object.keys(environment).length > 0 ? `environment {
    variables = ${JSON.stringify(environment, null, 2)}
  }` : ''}

  ${vpc ? `vpc_config {
    subnet_ids         = ${JSON.stringify(vpc.subnetIds)}
    security_group_ids = ${JSON.stringify(vpc.securityGroupIds)}
  }` : ''}
}

${!roleArn ? `resource "aws_iam_role" "lambda_role" {
  name = "philjs-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "lambda.amazonaws.com"
      }
    }]
  })
}

resource "aws_iam_role_policy_attachment" "lambda_basic" {
  role       = aws_iam_role.lambda_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}` : ''}

resource "aws_apigatewayv2_api" "philjs_api" {
  name          = "philjs-api"
  protocol_type = "HTTP"
  ${apiGateway?.cors ? `cors_configuration {
    allow_origins = ["*"]
    allow_methods = ["*"]
    allow_headers = ["*"]
  }` : ''}
}

resource "aws_apigatewayv2_integration" "philjs_integration" {
  api_id           = aws_apigatewayv2_api.philjs_api.id
  integration_type = "AWS_PROXY"
  integration_uri  = aws_lambda_function.philjs_app.invoke_arn
}

resource "aws_apigatewayv2_route" "philjs_route" {
  api_id    = aws_apigatewayv2_api.philjs_api.id
  route_key = "ANY /{proxy+}"
  target    = "integrations/\${aws_apigatewayv2_integration.philjs_integration.id}"
}

resource "aws_apigatewayv2_stage" "philjs_stage" {
  api_id      = aws_apigatewayv2_api.philjs_api.id
  name        = "${apiGateway?.stageName || 'prod'}"
  auto_deploy = true
}

resource "aws_lambda_permission" "api_gateway" {
  statement_id  = "AllowAPIGatewayInvoke"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.philjs_app.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "\${aws_apigatewayv2_api.philjs_api.execution_arn}/*/*"
}

${s3 ? `resource "aws_s3_bucket" "static_assets" {
  bucket = "${s3.bucket}"
}

resource "aws_s3_bucket_public_access_block" "static_assets" {
  bucket = aws_s3_bucket.static_assets.id

  block_public_acls       = false
  block_public_policy     = false
  ignore_public_acls      = false
  restrict_public_buckets = false
}

resource "aws_s3_bucket_website_configuration" "static_assets" {
  bucket = aws_s3_bucket.static_assets.id

  index_document {
    suffix = "index.html"
  }
}

resource "aws_s3_bucket_policy" "static_assets" {
  bucket = aws_s3_bucket.static_assets.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Sid       = "PublicReadGetObject"
      Effect    = "Allow"
      Principal = "*"
      Action    = "s3:GetObject"
      Resource  = "\${aws_s3_bucket.static_assets.arn}/*"
    }]
  })
}` : ''}

output "api_endpoint" {
  value = aws_apigatewayv2_stage.philjs_stage.invoke_url
}

output "lambda_function_name" {
  value = aws_lambda_function.philjs_app.function_name
}

${s3 ? `output "s3_bucket_name" {
  value = aws_s3_bucket.static_assets.bucket
}

output "s3_website_endpoint" {
  value = aws_s3_bucket_website_configuration.static_assets.website_endpoint
}` : ''}
`;
    }
    function generateDeployScript() {
        return `#!/bin/bash
# PhilJS AWS Lambda Deployment Script

set -e

echo "Building Lambda function..."
cd lambda
npm install --production
cd ..

echo "Creating deployment package..."
cd lambda
zip -r ../lambda.zip . -x "*.git*" "node_modules/aws-sdk/*"
cd ..

${generateSAM ? `
echo "Deploying with SAM..."
sam build
sam deploy --guided
` : ''}

${generateServerless ? `
echo "Deploying with Serverless Framework..."
serverless deploy
` : ''}

${generateTerraform ? `
echo "Deploying with Terraform..."
terraform init
terraform apply
` : ''}

${s3 ? `
echo "Uploading static assets to S3..."
aws s3 sync s3/ s3://${s3.bucket}${s3.prefix ? `/${s3.prefix}` : ''} \\
  --delete \\
  ${s3.cacheControl ? `--cache-control "${s3.cacheControl}"` : ''} \\
  --region ${s3.region || region}
` : ''}

${cloudfront ? `
echo "Invalidating CloudFront cache..."
aws cloudfront create-invalidation \\
  --distribution-id ${cloudfront.distributionId} \\
  --paths "/*"
` : ''}

echo "Deployment complete!"
`;
    }
    function generateTypeScriptTypes() {
        return `// PhilJS AWS Lambda Types
// Generated by PhilJS Adapters

import type { Context, APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';

declare module '@philjs/ssr' {
  interface Platform {
    name: 'aws-lambda';
    edge: false;
    context?: Context;
    event?: APIGatewayProxyEvent | any;
    region: string;
    ${s3 ? 's3?: S3Helpers;' : ''}
  }
}

${s3 ? `
export interface S3Helpers {
  getObject(key: string): Promise<any>;
  putObject(key: string, body: any, contentType?: string): Promise<void>;
  deleteObject(key: string): Promise<void>;
  listObjects(prefix?: string): Promise<string[]>;
}
` : ''}

export {};
`;
    }
    function createS3Helpers() {
        return {
            async getObject(key) {
                const { S3Client, GetObjectCommand } = await import('@aws-sdk/client-s3');
                const client = new S3Client({ region: s3?.region || region });
                const command = new GetObjectCommand({
                    Bucket: s3.bucket,
                    Key: key,
                });
                return client.send(command);
            },
            async putObject(key, body, contentType) {
                const { S3Client, PutObjectCommand } = await import('@aws-sdk/client-s3');
                const client = new S3Client({ region: s3?.region || region });
                const commandInput = {
                    Bucket: s3.bucket,
                    Key: key,
                    Body: body,
                };
                if (contentType !== undefined) {
                    commandInput.ContentType = contentType;
                }
                const command = new PutObjectCommand(commandInput);
                return client.send(command);
            },
            async deleteObject(key) {
                const { S3Client, DeleteObjectCommand } = await import('@aws-sdk/client-s3');
                const client = new S3Client({ region: s3?.region || region });
                const command = new DeleteObjectCommand({
                    Bucket: s3.bucket,
                    Key: key,
                });
                return client.send(command);
            },
            async listObjects(prefix) {
                const { S3Client, ListObjectsV2Command } = await import('@aws-sdk/client-s3');
                const client = new S3Client({ region: s3?.region || region });
                const commandInput = {
                    Bucket: s3.bucket,
                };
                if (prefix !== undefined) {
                    commandInput.Prefix = prefix;
                }
                const command = new ListObjectsV2Command(commandInput);
                const response = await client.send(command);
                return response.Contents?.map((obj) => obj.Key || '') || [];
            },
        };
    }
}
// AWS-specific utilities
export function getAWSContext() {
    return globalThis.awsContext;
}
export function getRemainingTimeMs() {
    const context = getAWSContext();
    return context?.getRemainingTimeInMillis?.() || 0;
}
export function getRequestId() {
    const context = getAWSContext();
    return context?.awsRequestId || '';
}
export function getS3AssetUrl(key, bucket) {
    return `https://${bucket}.s3.amazonaws.com/${key}`;
}
export default awsLambdaAdapter;
//# sourceMappingURL=index.js.map