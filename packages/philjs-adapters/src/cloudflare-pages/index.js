/**
 * PhilJS Cloudflare Pages Adapter
 *
 * Full-featured Cloudflare Pages deployment with:
 * - KV bindings support
 * - D1 database support
 * - R2 storage support
 * - Durable Objects support
 * - Static asset handling
 */
import { writeFileSync, mkdirSync, cpSync, existsSync } from 'fs';
import { join } from 'path';
export function cloudflarePagesAdapter(config = {}) {
    const { outDir = '.cloudflare', kv = [], d1 = [], r2 = [], durableObjects = [], services = [], queues, analytics = [], vars = {}, compatibilityDate = '2024-01-01', compatibilityFlags = [], excludeAssets = ['/static/*', '/assets/*', '/_philjs/*', '/favicon.ico', '/robots.txt'], routes, generateWranglerConfig = true, } = config;
    return {
        name: 'cloudflare-pages',
        edge: true,
        edgeConfig: {
            regions: ['global'], // Cloudflare deploys globally
        },
        async adapt() {
            console.log('Building for Cloudflare Pages...');
            // Create output directory structure
            mkdirSync(outDir, { recursive: true });
            mkdirSync(join(outDir, 'functions'), { recursive: true });
            // Generate _worker.js (main handler)
            writeFileSync(join(outDir, '_worker.js'), generateWorkerScript());
            // Generate _routes.json for static asset handling
            const routesConfig = {
                version: 1,
                include: routes?.include || ['/*'],
                exclude: routes?.exclude || excludeAssets,
            };
            writeFileSync(join(outDir, '_routes.json'), JSON.stringify(routesConfig, null, 2));
            // Generate wrangler.toml for local development
            if (generateWranglerConfig) {
                writeFileSync(join(outDir, 'wrangler.toml'), generateWranglerToml());
            }
            // Generate TypeScript bindings
            writeFileSync(join(outDir, 'env.d.ts'), generateTypeScriptBindings());
            // Copy static assets
            const staticDir = config.static?.assets || 'public';
            if (existsSync(staticDir)) {
                cpSync(staticDir, outDir, { recursive: true });
            }
            // Copy prerendered pages
            if (existsSync('.philjs/prerendered')) {
                cpSync('.philjs/prerendered', outDir, { recursive: true });
            }
            console.log('Cloudflare Pages build complete');
        },
        getHandler() {
            return async (request, env, ctx) => {
                const url = new URL(request.url);
                const requestContext = {
                    url,
                    method: request.method,
                    headers: request.headers,
                    body: request.body,
                    params: {},
                    platform: {
                        name: 'cloudflare-pages',
                        edge: true,
                        env, // All bindings (KV, R2, D1, etc.)
                        ctx, // ExecutionContext
                        kv: createKVHelpers(env, kv),
                        d1: createD1Helpers(env, d1),
                        r2: createR2Helpers(env, r2),
                    },
                };
                const { handleRequest } = await import('@philjs/ssr');
                return handleRequest(requestContext);
            };
        },
    };
    function generateWorkerScript() {
        return `// PhilJS Cloudflare Pages Worker
// Generated by PhilJS Adapters

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);

    // Create request context with all bindings
    const context = {
      url,
      method: request.method,
      headers: request.headers,
      body: request.body,
      params: {},
      platform: {
        name: 'cloudflare-pages',
        edge: true,
        env, // All bindings
        ctx, // ExecutionContext for waitUntil, passThroughOnException
      },
    };

    try {
      const { handleRequest } = await import('@philjs/ssr');
      return await handleRequest(context);
    } catch (error) {
      console.error('PhilJS request error:', error);

      // Return error response
      return new Response(
        JSON.stringify({
          error: 'Internal Server Error',
          message: error.message,
        }),
        {
          status: 500,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }
  },

  ${queues?.consumers?.length ? `async queue(batch, env, ctx) {
    // Queue consumer handler
    for (const message of batch.messages) {
      try {
        const { handleQueueMessage } = await import('@philjs/ssr');
        await handleQueueMessage(message.body, { env, ctx });
        message.ack();
      } catch (error) {
        console.error('Queue message processing error:', error);
        message.retry();
      }
    }
  },` : ''}

  ${durableObjects?.length ? `// Durable Object handlers would go here` : ''}
};
`;
    }
    function generateWranglerToml() {
        const lines = [
            '# PhilJS Cloudflare Pages Configuration',
            '# Generated by PhilJS Adapters',
            '',
            'name = "philjs-app"',
            `compatibility_date = "${compatibilityDate}"`,
            'pages_build_output_dir = "."',
        ];
        if (compatibilityFlags.length > 0) {
            lines.push(`compatibility_flags = [${compatibilityFlags.map(f => `"${f}"`).join(', ')}]`);
        }
        // KV Namespaces
        if (kv.length > 0) {
            lines.push('');
            lines.push('# KV Namespaces');
            for (const binding of kv) {
                lines.push('[[kv_namespaces]]');
                lines.push(`binding = "${binding.binding}"`);
                lines.push(`id = "${binding.id}"`);
                if (binding.preview_id) {
                    lines.push(`preview_id = "${binding.preview_id}"`);
                }
                lines.push('');
            }
        }
        // D1 Databases
        if (d1.length > 0) {
            lines.push('# D1 Databases');
            for (const binding of d1) {
                lines.push('[[d1_databases]]');
                lines.push(`binding = "${binding.binding}"`);
                lines.push(`database_id = "${binding.database_id}"`);
                lines.push(`database_name = "${binding.database_name}"`);
                if (binding.preview_database_id) {
                    lines.push(`preview_database_id = "${binding.preview_database_id}"`);
                }
                lines.push('');
            }
        }
        // R2 Buckets
        if (r2.length > 0) {
            lines.push('# R2 Buckets');
            for (const binding of r2) {
                lines.push('[[r2_buckets]]');
                lines.push(`binding = "${binding.binding}"`);
                lines.push(`bucket_name = "${binding.bucket_name}"`);
                if (binding.preview_bucket_name) {
                    lines.push(`preview_bucket_name = "${binding.preview_bucket_name}"`);
                }
                lines.push('');
            }
        }
        // Durable Objects
        if (durableObjects.length > 0) {
            lines.push('# Durable Objects');
            lines.push('[[durable_objects.bindings]]');
            for (const binding of durableObjects) {
                lines.push(`name = "${binding.binding}"`);
                lines.push(`class_name = "${binding.class_name}"`);
                if (binding.script_name) {
                    lines.push(`script_name = "${binding.script_name}"`);
                }
                if (binding.environment) {
                    lines.push(`environment = "${binding.environment}"`);
                }
                lines.push('');
            }
        }
        // Service Bindings
        if (services.length > 0) {
            lines.push('# Service Bindings');
            for (const binding of services) {
                lines.push('[[services]]');
                lines.push(`binding = "${binding.binding}"`);
                lines.push(`service = "${binding.service}"`);
                if (binding.environment) {
                    lines.push(`environment = "${binding.environment}"`);
                }
                lines.push('');
            }
        }
        // Queue Producers
        if (queues?.producers?.length) {
            lines.push('# Queue Producers');
            for (const producer of queues.producers) {
                lines.push('[[queues.producers]]');
                lines.push(`binding = "${producer.binding}"`);
                lines.push(`queue = "${producer.queue}"`);
                lines.push('');
            }
        }
        // Queue Consumers
        if (queues?.consumers?.length) {
            lines.push('# Queue Consumers');
            for (const consumer of queues.consumers) {
                lines.push('[[queues.consumers]]');
                lines.push(`queue = "${consumer.queue}"`);
                if (consumer.max_batch_size) {
                    lines.push(`max_batch_size = ${consumer.max_batch_size}`);
                }
                if (consumer.max_batch_timeout) {
                    lines.push(`max_batch_timeout = ${consumer.max_batch_timeout}`);
                }
                if (consumer.max_retries) {
                    lines.push(`max_retries = ${consumer.max_retries}`);
                }
                if (consumer.dead_letter_queue) {
                    lines.push(`dead_letter_queue = "${consumer.dead_letter_queue}"`);
                }
                lines.push('');
            }
        }
        // Analytics Engine
        if (analytics.length > 0) {
            lines.push('# Analytics Engine');
            for (const binding of analytics) {
                lines.push('[[analytics_engine_datasets]]');
                lines.push(`binding = "${binding.binding}"`);
                if (binding.dataset) {
                    lines.push(`dataset = "${binding.dataset}"`);
                }
                lines.push('');
            }
        }
        // Environment Variables
        if (Object.keys(vars).length > 0) {
            lines.push('# Environment Variables');
            lines.push('[vars]');
            for (const [key, value] of Object.entries(vars)) {
                lines.push(`${key} = "${value}"`);
            }
        }
        return lines.join('\n');
    }
    function generateTypeScriptBindings() {
        const bindings = [
            '// PhilJS Cloudflare Pages Environment Bindings',
            '// Generated by PhilJS Adapters',
            '',
            'interface Env {',
        ];
        // KV bindings
        for (const binding of kv) {
            bindings.push(`  ${binding.binding}: KVNamespace;`);
        }
        // D1 bindings
        for (const binding of d1) {
            bindings.push(`  ${binding.binding}: D1Database;`);
        }
        // R2 bindings
        for (const binding of r2) {
            bindings.push(`  ${binding.binding}: R2Bucket;`);
        }
        // Durable Objects bindings
        for (const binding of durableObjects) {
            bindings.push(`  ${binding.binding}: DurableObjectNamespace;`);
        }
        // Service bindings
        for (const binding of services) {
            bindings.push(`  ${binding.binding}: Fetcher;`);
        }
        // Queue bindings
        if (queues?.producers) {
            for (const producer of queues.producers) {
                bindings.push(`  ${producer.binding}: Queue;`);
            }
        }
        // Analytics bindings
        for (const binding of analytics) {
            bindings.push(`  ${binding.binding}: AnalyticsEngineDataset;`);
        }
        // Environment variables
        for (const key of Object.keys(vars)) {
            bindings.push(`  ${key}: string;`);
        }
        bindings.push('}');
        bindings.push('');
        bindings.push('export { Env };');
        return bindings.join('\n');
    }
}
// Helper functions to create typed accessors for bindings
function createKVHelpers(env, bindings = []) {
    const helpers = {};
    for (const binding of bindings) {
        if (env?.[binding.binding]) {
            helpers[binding.binding] = {
                get: (key) => env[binding.binding].get(key),
                getJSON: (key) => env[binding.binding].get(key, 'json'),
                getText: (key) => env[binding.binding].get(key, 'text'),
                getArrayBuffer: (key) => env[binding.binding].get(key, 'arrayBuffer'),
                put: (key, value, options) => env[binding.binding].put(key, value, options),
                delete: (key) => env[binding.binding].delete(key),
                list: (options) => env[binding.binding].list(options),
            };
        }
    }
    return helpers;
}
function createD1Helpers(env, bindings = []) {
    const helpers = {};
    for (const binding of bindings) {
        if (env?.[binding.binding]) {
            helpers[binding.binding] = {
                prepare: (query) => env[binding.binding].prepare(query),
                exec: (query) => env[binding.binding].exec(query),
                batch: (statements) => env[binding.binding].batch(statements),
                dump: () => env[binding.binding].dump(),
            };
        }
    }
    return helpers;
}
function createR2Helpers(env, bindings = []) {
    const helpers = {};
    for (const binding of bindings) {
        if (env?.[binding.binding]) {
            helpers[binding.binding] = {
                get: (key) => env[binding.binding].get(key),
                put: (key, value, options) => env[binding.binding].put(key, value, options),
                delete: (key) => env[binding.binding].delete(key),
                list: (options) => env[binding.binding].list(options),
                head: (key) => env[binding.binding].head(key),
            };
        }
    }
    return helpers;
}
// Cloudflare-specific utilities
export function getCloudflareEnv() {
    return globalThis.env;
}
export function getExecutionContext() {
    return globalThis.ctx;
}
export function waitUntil(promise) {
    const ctx = getExecutionContext();
    if (ctx?.waitUntil) {
        ctx.waitUntil(promise);
    }
}
export function passThroughOnException() {
    const ctx = getExecutionContext();
    if (ctx?.passThroughOnException) {
        ctx.passThroughOnException();
    }
}
// KV helper
export function createKVNamespace(namespace) {
    return {
        get: (key) => namespace.get(key),
        getJSON: (key) => namespace.get(key, 'json'),
        getText: (key) => namespace.get(key, 'text'),
        getArrayBuffer: (key) => namespace.get(key, 'arrayBuffer'),
        getStream: (key) => namespace.get(key, 'stream'),
        put: (key, value, options) => namespace.put(key, value, options),
        delete: (key) => namespace.delete(key),
        list: (options) => namespace.list(options),
    };
}
// D1 helper
export function createD1Database(database) {
    return {
        prepare: (query) => database.prepare(query),
        exec: (query) => database.exec(query),
        batch: (statements) => database.batch(statements),
        dump: () => database.dump(),
    };
}
// R2 helper
export function createR2Bucket(bucket) {
    return {
        get: (key, options) => bucket.get(key, options),
        put: (key, value, options) => bucket.put(key, value, options),
        delete: (keys) => bucket.delete(keys),
        list: (options) => bucket.list(options),
        head: (key) => bucket.head(key),
    };
}
export default cloudflarePagesAdapter;
//# sourceMappingURL=index.js.map