/**
 * PhilJS Netlify Adapter
 *
 * Full-featured Netlify deployment with:
 * - Netlify Functions (serverless)
 * - Edge Functions
 * - Blob storage
 * - Form handling
 * - Redirects and rewrites
 * - Headers configuration
 */
import { writeFileSync, mkdirSync, cpSync, existsSync } from 'fs';
import { join } from 'path';
export function netlifyAdapter(config = {}) {
    const { outDir = '.netlify', edge = false, functions: functionsConfig, edgeFunctions: edgeFunctionsConfig, redirects, rewrites, headers, blob, forms, images, splitTesting, } = config;
    const functionsDir = functionsConfig?.directory || 'functions';
    const edgeFunctionsDir = edgeFunctionsConfig?.directory || 'edge-functions';
    return {
        name: 'netlify',
        edge,
        ...(edge && {
            edgeConfig: {
                regions: ['global'], // Netlify Edge Functions deploy globally
            },
        }),
        ...(!edge && {
            serverless: true,
            functionConfig: {
                runtime: `nodejs${functionsConfig?.nodeVersion || '20.x'}`,
            },
        }),
        async adapt() {
            console.log(`Building for Netlify ${edge ? 'Edge Functions' : 'Functions'}...`);
            // Create output structure
            mkdirSync(join(outDir, 'functions'), { recursive: true });
            mkdirSync(join(outDir, 'edge-functions'), { recursive: true });
            mkdirSync(join(outDir, 'publish'), { recursive: true });
            // Generate netlify.toml
            writeFileSync(join(outDir, 'netlify.toml'), generateNetlifyToml());
            // Generate _redirects file
            if (redirects || rewrites) {
                writeFileSync(join(outDir, 'publish', '_redirects'), generateRedirects());
            }
            // Generate _headers file
            if (headers) {
                writeFileSync(join(outDir, 'publish', '_headers'), generateHeaders());
            }
            // Generate function handler
            if (edge) {
                await generateEdgeFunction();
            }
            else {
                await generateServerlessFunction();
            }
            // Copy static assets
            const staticDir = config.static?.assets || 'public';
            if (existsSync(staticDir)) {
                cpSync(staticDir, join(outDir, 'publish'), { recursive: true });
            }
            // Copy prerendered pages
            if (existsSync('.philjs/prerendered')) {
                cpSync('.philjs/prerendered', join(outDir, 'publish'), { recursive: true });
            }
            // Generate TypeScript types
            writeFileSync(join(outDir, 'types.d.ts'), generateTypeScriptTypes());
            console.log(`Netlify build complete: ${outDir}`);
        },
        getHandler() {
            return async (request, context) => {
                const url = new URL(request.url);
                const requestContext = {
                    url,
                    method: request.method,
                    headers: request.headers,
                    body: request.body,
                    params: {},
                    platform: {
                        name: 'netlify',
                        edge,
                        context,
                        blob: blob ? createBlobHelpers() : undefined,
                    },
                };
                const { handleRequest } = await import('@philjs/ssr');
                return handleRequest(requestContext);
            };
        },
    };
    function generateNetlifyToml() {
        const lines = [
            '# PhilJS Netlify Configuration',
            '# Generated by PhilJS Adapters',
            '',
            '[build]',
            '  publish = "publish"',
            `  functions = "${functionsDir}"`,
        ];
        if (functionsConfig?.includedFiles) {
            lines.push(`  included_files = [${functionsConfig.includedFiles.map(f => `"${f}"`).join(', ')}]`);
        }
        if (functionsConfig?.externalNodeModules) {
            lines.push(`  external_node_modules = [${functionsConfig.externalNodeModules.map(m => `"${m}"`).join(', ')}]`);
        }
        // Functions configuration
        if (!edge) {
            lines.push('');
            lines.push('[functions]');
            lines.push(`  node_bundler = "esbuild"`);
            if (functionsConfig?.nodeVersion) {
                lines.push(`  node_version = "${functionsConfig.nodeVersion}"`);
            }
        }
        // Edge Functions configuration
        if (edge && edgeFunctionsConfig?.functions) {
            lines.push('');
            for (const func of edgeFunctionsConfig.functions) {
                lines.push('[[edge_functions]]');
                lines.push(`  path = "${func.path}"`);
                lines.push(`  function = "${func.function}"`);
                lines.push('');
            }
        }
        // Redirects (if not using _redirects file)
        if (redirects && redirects.length > 0 && !hasConditions(redirects)) {
            lines.push('');
            lines.push('# Redirects');
            for (const redirect of redirects) {
                lines.push('[[redirects]]');
                lines.push(`  from = "${redirect.from}"`);
                lines.push(`  to = "${redirect.to}"`);
                lines.push(`  status = ${redirect.status || (redirect.force ? 301 : 302)}`);
                if (redirect.force) {
                    lines.push('  force = true');
                }
                lines.push('');
            }
        }
        // Split testing
        if (splitTesting) {
            lines.push('');
            lines.push('# Split Testing');
            for (const test of splitTesting) {
                lines.push('[[redirects]]');
                lines.push(`  from = "${test.path}"`);
                lines.push(`  to = "${test.path}"`);
                lines.push('  status = 200');
                const conditions = test.branches.map(b => `${b.branch}=${b.weight}`).join(' ');
                lines.push(`  conditions = {Branch = "${conditions}"}`);
                lines.push('');
            }
        }
        return lines.join('\n');
    }
    function generateRedirects() {
        const lines = [
            '# PhilJS Netlify Redirects',
            '# Generated by PhilJS Adapters',
            '',
        ];
        // Add redirects
        if (redirects) {
            for (const redirect of redirects) {
                let line = `${redirect.from} ${redirect.to} ${redirect.status || 301}`;
                if (redirect.force) {
                    line += '!';
                }
                // Add conditions
                if (redirect.conditions) {
                    const conditions = [];
                    if (redirect.conditions.country) {
                        conditions.push(`Country=${redirect.conditions.country.join(',')}`);
                    }
                    if (redirect.conditions.language) {
                        conditions.push(`Language=${redirect.conditions.language.join(',')}`);
                    }
                    if (redirect.conditions.role) {
                        conditions.push(`Role=${redirect.conditions.role.join(',')}`);
                    }
                    if (conditions.length > 0) {
                        line += ` ${conditions.join(' ')}`;
                    }
                }
                lines.push(line);
            }
        }
        // Add rewrites
        if (rewrites) {
            lines.push('');
            lines.push('# Rewrites');
            for (const rewrite of rewrites) {
                let line = `${rewrite.from} ${rewrite.to} ${rewrite.status || 200}`;
                // Add conditions
                if (rewrite.conditions) {
                    const conditions = [];
                    if (rewrite.conditions.country) {
                        conditions.push(`Country=${rewrite.conditions.country.join(',')}`);
                    }
                    if (rewrite.conditions.language) {
                        conditions.push(`Language=${rewrite.conditions.language.join(',')}`);
                    }
                    if (rewrite.conditions.role) {
                        conditions.push(`Role=${rewrite.conditions.role.join(',')}`);
                    }
                    if (conditions.length > 0) {
                        line += ` ${conditions.join(' ')}`;
                    }
                }
                lines.push(line);
            }
        }
        // Catch-all for SPA
        lines.push('');
        lines.push('# SPA fallback');
        lines.push('/* /index.html 200');
        return lines.join('\n');
    }
    function generateHeaders() {
        const lines = [
            '# PhilJS Netlify Headers',
            '# Generated by PhilJS Adapters',
            '',
        ];
        if (headers) {
            for (const header of headers) {
                lines.push(header.for);
                for (const [key, value] of Object.entries(header.values)) {
                    lines.push(`  ${key}: ${value}`);
                }
                lines.push('');
            }
        }
        // Add default security headers
        lines.push('/*');
        lines.push('  X-Frame-Options: DENY');
        lines.push('  X-XSS-Protection: 1; mode=block');
        lines.push('  X-Content-Type-Options: nosniff');
        lines.push('  Referrer-Policy: strict-origin-when-cross-origin');
        return lines.join('\n');
    }
    async function generateEdgeFunction() {
        const edgeFunctionDir = join(outDir, 'edge-functions');
        mkdirSync(edgeFunctionDir, { recursive: true });
        const edgeFunctionCode = `// PhilJS Netlify Edge Function
// Generated by PhilJS Adapters

import { Context } from "@netlify/edge-functions";

export default async (request: Request, context: Context) => {
  const url = new URL(request.url);

  const requestContext = {
    url,
    method: request.method,
    headers: request.headers,
    body: request.body,
    params: {},
    platform: {
      name: 'netlify',
      edge: true,
      context,
      geo: context.geo,
      cookies: context.cookies,
      ${blob ? 'blob: true,' : ''}
    },
  };

  try {
    const { handleRequest } = await import('@philjs/ssr');
    return await handleRequest(requestContext);
  } catch (error) {
    console.error('PhilJS request error:', error);
    return new Response(
      JSON.stringify({
        error: 'Internal Server Error',
        message: error.message,
      }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' },
      }
    );
  }
};

export const config = {
  path: "/*",
  excludedPath: ["/static/*", "/assets/*", "/_philjs/*"],
};
`;
        writeFileSync(join(edgeFunctionDir, 'philjs.ts'), edgeFunctionCode);
        // Create manifest
        const manifest = {
            version: 1,
            functions: [
                {
                    function: 'philjs',
                    path: '/*',
                },
            ],
        };
        writeFileSync(join(edgeFunctionDir, 'manifest.json'), JSON.stringify(manifest, null, 2));
    }
    async function generateServerlessFunction() {
        const functionDir = join(outDir, functionsDir);
        mkdirSync(functionDir, { recursive: true });
        const functionCode = `// PhilJS Netlify Function
// Generated by PhilJS Adapters

const { builder } = require('@netlify/functions');

const handler = async (event, context) => {
  const url = new URL(event.rawUrl);

  // Convert Netlify event to Web API Request
  const headers = new Headers();
  for (const [key, value] of Object.entries(event.headers)) {
    headers.append(key, value);
  }

  const requestContext = {
    url,
    method: event.httpMethod,
    headers,
    body: event.body ? new ReadableStream({
      start(controller) {
        controller.enqueue(new TextEncoder().encode(event.body));
        controller.close();
      }
    }) : null,
    params: event.pathParameters || {},
    platform: {
      name: 'netlify',
      edge: false,
      context,
      event,
      ${blob ? 'blob: true,' : ''}
    },
  };

  try {
    const { handleRequest } = await import('@philjs/ssr');
    const response = await handleRequest(requestContext);

    // Convert Web API Response to Netlify response
    const responseHeaders = {};
    response.headers.forEach((value, key) => {
      responseHeaders[key] = value;
    });

    let body = '';
    if (response.body) {
      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        body += decoder.decode(value, { stream: true });
      }
    }

    return {
      statusCode: response.status,
      headers: responseHeaders,
      body,
    };
  } catch (error) {
    console.error('PhilJS request error:', error);
    return {
      statusCode: 500,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        error: 'Internal Server Error',
        message: error.message,
      }),
    };
  }
};

exports.handler = builder(handler);
`;
        writeFileSync(join(functionDir, 'philjs.js'), functionCode);
    }
    function generateTypeScriptTypes() {
        return `// PhilJS Netlify Types
// Generated by PhilJS Adapters

import type { Context } from '@netlify/edge-functions';

declare module '@philjs/ssr' {
  interface Platform {
    name: 'netlify';
    edge: boolean;
    context?: Context | any;
    geo?: {
      city?: string;
      country?: { code?: string; name?: string };
      subdivision?: { code?: string; name?: string };
    };
    cookies?: any;
    ${blob ? 'blob?: NetlifyBlob;' : ''}
  }
}

${blob ? `
export interface NetlifyBlob {
  get(key: string): Promise<Blob | null>;
  set(key: string, data: Blob | string): Promise<void>;
  delete(key: string): Promise<void>;
  list(options?: { prefix?: string }): Promise<string[]>;
}
` : ''}

export {};
`;
    }
    function hasConditions(items = []) {
        return items.some(item => item.conditions);
    }
    function createBlobHelpers() {
        return {
            async get(key) {
                const { getStore } = await import('@netlify/blobs');
                const store = getStore('philjs');
                return store.get(key);
            },
            async set(key, data) {
                const { getStore } = await import('@netlify/blobs');
                const store = getStore('philjs');
                return store.set(key, data);
            },
            async delete(key) {
                const { getStore } = await import('@netlify/blobs');
                const store = getStore('philjs');
                return store.delete(key);
            },
            async list(options) {
                const { getStore } = await import('@netlify/blobs');
                const store = getStore('philjs');
                return store.list(options);
            },
        };
    }
}
// Netlify-specific utilities
export function getNetlifyContext() {
    return globalThis.netlifyContext;
}
export function netlifyImageCDN(src, options = {}) {
    const params = new URLSearchParams();
    if (options.width)
        params.set('w', String(options.width));
    if (options.height)
        params.set('h', String(options.height));
    if (options.fit)
        params.set('fit', options.fit);
    if (options.position)
        params.set('position', options.position);
    if (options.quality)
        params.set('q', String(options.quality));
    const queryString = params.toString();
    return queryString ? `/.netlify/images?url=${encodeURIComponent(src)}&${queryString}` : src;
}
export default netlifyAdapter;
//# sourceMappingURL=adapter.js.map