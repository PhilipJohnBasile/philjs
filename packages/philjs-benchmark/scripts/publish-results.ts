#!/usr/bin/env tsx
/**
 * Publish benchmark results in various formats.
 * Supports GitHub Pages, npm package, and API endpoints.
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { fileURLToPath } from 'url';
import type { FullBenchmarkReport, BenchmarkResult } from '../src/types.js';
import { generateAndSaveCharts, generateComparisonMarkdown, loadComparisonData } from '../src/comparison/chart-generator.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const RESULTS_DIR = path.join(__dirname, '..', 'results');

interface PublishOptions {
  format: 'json' | 'markdown' | 'html' | 'all';
  output: string;
  includeComparison: boolean;
  generateCharts: boolean;
  githubPages: boolean;
  createBadges: boolean;
}

/**
 * Parse command line arguments.
 */
function parseArgs(): PublishOptions {
  const args = process.argv.slice(2);

  return {
    format: (args.find(a => a.startsWith('--format='))?.split('=')[1] as any) || 'all',
    output: args.find(a => a.startsWith('--output='))?.split('=')[1] || path.join(RESULTS_DIR, 'publish'),
    includeComparison: !args.includes('--no-comparison'),
    generateCharts: !args.includes('--no-charts'),
    githubPages: args.includes('--github-pages'),
    createBadges: !args.includes('--no-badges'),
  };
}

/**
 * Load latest benchmark results.
 */
async function loadLatestResults(): Promise<FullBenchmarkReport> {
  const latestPath = path.join(RESULTS_DIR, 'latest.json');

  try {
    const content = await fs.readFile(latestPath, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    throw new Error(`Failed to load results from ${latestPath}. Run benchmarks first.`);
  }
}

/**
 * Generate JSON export.
 */
async function publishJSON(report: FullBenchmarkReport, outputDir: string): Promise<void> {
  const outputPath = path.join(outputDir, 'results.json');
  await fs.writeFile(outputPath, JSON.stringify(report, null, 2), 'utf-8');
  console.log(`âœ“ JSON published to ${outputPath}`);
}

/**
 * Generate Markdown export.
 */
async function publishMarkdown(
  report: FullBenchmarkReport,
  outputDir: string,
  includeComparison: boolean
): Promise<void> {
  let md = `# PhilJS Benchmark Results\n\n`;
  md += `**Version:** ${report.version}\n`;
  md += `**Date:** ${new Date(report.timestamp).toLocaleDateString()}\n`;
  md += `**Environment:** ${report.environment.runtime} ${report.environment.runtimeVersion} on ${report.environment.os}\n\n`;

  md += `## Summary\n\n`;
  md += `- Total Benchmarks: ${report.summary.totalBenchmarks}\n`;
  md += `- Passed: ${report.summary.passed}\n`;
  md += `- Failed: ${report.summary.failed}\n\n`;

  // Framework benchmarks
  if (report.suites.framework) {
    md += `## Framework Benchmarks\n\n`;
    md += `| Benchmark | Mean | Median | Min | Max | Std Dev |\n`;
    md += `|-----------|------|--------|-----|-----|--------|\n`;

    for (const result of report.suites.framework.results) {
      md += `| ${result.name} | ${result.mean.toFixed(2)}${result.unit} | ${result.median.toFixed(2)}${result.unit} | ${result.min.toFixed(2)}${result.unit} | ${result.max.toFixed(2)}${result.unit} | ${result.stddev.toFixed(2)}${result.unit} |\n`;
    }
    md += '\n';
  }

  // Reactivity benchmarks
  if (report.suites.reactivity) {
    md += `## Reactivity Benchmarks\n\n`;
    md += `| Benchmark | Mean | Ops/sec |\n`;
    md += `|-----------|------|--------|\n`;

    for (const result of report.suites.reactivity.results) {
      md += `| ${result.name} | ${result.mean.toFixed(4)}${result.unit} | ${result.ops.toFixed(0)} |\n`;
    }
    md += '\n';
  }

  // SSR benchmarks
  if (report.suites.ssr) {
    md += `## SSR Benchmarks\n\n`;
    md += `| Benchmark | Mean | Ops/sec |\n`;
    md += `|-----------|------|--------|\n`;

    for (const result of report.suites.ssr.results) {
      md += `| ${result.name} | ${result.mean.toFixed(2)}${result.unit} | ${result.ops.toFixed(0)} |\n`;
    }
    md += '\n';
  }

  // Bundle size
  if (report.suites.bundle) {
    md += `## Bundle Size\n\n`;
    md += `| Metric | Size |\n`;
    md += `|--------|------|\n`;

    for (const result of report.suites.bundle.results) {
      const size = result.mean > 1024
        ? `${(result.mean / 1024).toFixed(2)} KB`
        : `${result.mean.toFixed(0)} B`;
      md += `| ${result.name} | ${size} |\n`;
    }
    md += '\n';
  }

  // Add comparison if requested
  if (includeComparison && report.suites.framework) {
    try {
      const frameworkData = await loadComparisonData();
      const comparisonMd = generateComparisonMarkdown(report.suites.framework.results, frameworkData);
      md += '\n' + comparisonMd;
    } catch (error) {
      console.warn('Warning: Could not generate comparison data');
    }
  }

  md += `\n---\n`;
  md += `*Generated by PhilJS Benchmark Suite on ${new Date().toISOString()}*\n`;

  const outputPath = path.join(outputDir, 'results.md');
  await fs.writeFile(outputPath, md, 'utf-8');
  console.log(`âœ“ Markdown published to ${outputPath}`);
}

/**
 * Generate HTML export.
 */
async function publishHTML(report: FullBenchmarkReport, outputDir: string): Promise<void> {
  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PhilJS Benchmark Results</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      padding: 2rem;
      line-height: 1.6;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 {
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 1rem;
    }
    .meta {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    .meta p { margin: 0.25rem 0; }
    h2 {
      color: #58a6ff;
      margin: 2rem 0 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #30363d;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      background: #161b22;
    }
    th, td {
      padding: 0.75rem;
      text-align: left;
      border-bottom: 1px solid #30363d;
    }
    th {
      background: #0d1117;
      font-weight: 600;
      color: #8b949e;
    }
    tr:hover { background: rgba(88, 166, 255, 0.05); }
    code {
      background: #21262d;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin: 2rem 0;
    }
    .stat-card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 1.5rem;
      text-align: center;
    }
    .stat-value {
      font-size: 2rem;
      font-weight: bold;
      color: #4f46e5;
    }
    .stat-label {
      color: #8b949e;
      margin-top: 0.5rem;
    }
    footer {
      margin-top: 3rem;
      padding-top: 2rem;
      border-top: 1px solid #30363d;
      text-align: center;
      color: #8b949e;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>PhilJS Benchmark Results</h1>

    <div class="meta">
      <p><strong>Version:</strong> ${report.version}</p>
      <p><strong>Date:</strong> ${new Date(report.timestamp).toLocaleString()}</p>
      <p><strong>Runtime:</strong> ${report.environment.runtime} ${report.environment.runtimeVersion}</p>
      <p><strong>OS:</strong> ${report.environment.os}</p>
      <p><strong>CPU:</strong> ${report.environment.cpu}</p>
      <p><strong>Memory:</strong> ${report.environment.memory}</p>
    </div>

    <div class="stats">
      <div class="stat-card">
        <div class="stat-value">${report.summary.totalBenchmarks}</div>
        <div class="stat-label">Total Benchmarks</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" style="color: #3fb950">${report.summary.passed}</div>
        <div class="stat-label">Passed</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" style="color: #f85149">${report.summary.failed}</div>
        <div class="stat-label">Failed</div>
      </div>
    </div>

    ${report.suites.framework ? generateBenchmarkTable('Framework Benchmarks', report.suites.framework.results) : ''}
    ${report.suites.reactivity ? generateBenchmarkTable('Reactivity Benchmarks', report.suites.reactivity.results) : ''}
    ${report.suites.ssr ? generateBenchmarkTable('SSR Benchmarks', report.suites.ssr.results) : ''}
    ${report.suites.bundle ? generateBenchmarkTable('Bundle Size', report.suites.bundle.results) : ''}

    <footer>
      <p>Generated by PhilJS Benchmark Suite</p>
      <p>${new Date().toISOString()}</p>
    </footer>
  </div>
</body>
</html>`;

  const outputPath = path.join(outputDir, 'results.html');
  await fs.writeFile(outputPath, html, 'utf-8');
  console.log(`âœ“ HTML published to ${outputPath}`);
}

function generateBenchmarkTable(title: string, results: BenchmarkResult[]): string {
  return `
    <h2>${title}</h2>
    <table>
      <thead>
        <tr>
          <th>Benchmark</th>
          <th>Mean</th>
          <th>Median</th>
          <th>Min</th>
          <th>Max</th>
          <th>Std Dev</th>
          <th>Samples</th>
        </tr>
      </thead>
      <tbody>
        ${results.map(r => `
          <tr>
            <td><code>${r.name}</code></td>
            <td><strong>${r.mean.toFixed(2)} ${r.unit}</strong></td>
            <td>${r.median.toFixed(2)} ${r.unit}</td>
            <td>${r.min.toFixed(2)} ${r.unit}</td>
            <td>${r.max.toFixed(2)} ${r.unit}</td>
            <td>${r.stddev.toFixed(2)} ${r.unit}</td>
            <td>${r.samples}</td>
          </tr>
        `).join('')}
      </tbody>
    </table>
  `;
}

/**
 * Generate GitHub Pages site.
 */
async function publishGitHubPages(report: FullBenchmarkReport, outputDir: string): Promise<void> {
  const pagesDir = path.join(outputDir, 'gh-pages');
  await fs.mkdir(pagesDir, { recursive: true });

  // Generate index.html
  await publishHTML(report, pagesDir);
  await fs.rename(
    path.join(pagesDir, 'results.html'),
    path.join(pagesDir, 'index.html')
  );

  // Generate comparison charts
  try {
    await generateAndSaveCharts(report, pagesDir);
  } catch (error) {
    console.warn('Warning: Could not generate comparison charts');
  }

  // Create _config.yml for GitHub Pages
  const config = `theme: jekyll-theme-minimal
title: PhilJS Benchmark Results
description: Performance benchmarks for PhilJS framework
`;
  await fs.writeFile(path.join(pagesDir, '_config.yml'), config, 'utf-8');

  // Create README
  const readme = `# PhilJS Benchmark Results

View the results at: https://YOUR_USERNAME.github.io/philjs/

## Files

- \`index.html\` - Main results page
- \`comparison.html\` - Framework comparison charts
- \`results.json\` - Raw benchmark data

## Updating

Run \`npm run bench:all -- --save\` then \`npm run publish -- --github-pages\` to update.
`;
  await fs.writeFile(path.join(pagesDir, 'README.md'), readme, 'utf-8');

  console.log(`âœ“ GitHub Pages site published to ${pagesDir}`);
  console.log(`  Deploy with: git subtree push --prefix ${path.relative(process.cwd(), pagesDir)} origin gh-pages`);
}

/**
 * Generate performance badges.
 */
async function generateBadges(report: FullBenchmarkReport, outputDir: string): Promise<void> {
  const badgesDir = path.join(outputDir, 'badges');
  await fs.mkdir(badgesDir, { recursive: true });

  const generateBadgeSVG = (label: string, value: string, color: string): string => {
    const labelWidth = label.length * 7 + 10;
    const valueWidth = value.length * 7 + 10;
    const totalWidth = labelWidth + valueWidth;

    return `<svg xmlns="http://www.w3.org/2000/svg" width="${totalWidth}" height="20">
  <linearGradient id="smooth" x2="0" y2="100%">
    <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
    <stop offset="1" stop-opacity=".1"/>
  </linearGradient>
  <rect rx="3" width="${totalWidth}" height="20" fill="#555"/>
  <rect rx="3" x="${labelWidth}" width="${valueWidth}" height="20" fill="${color}"/>
  <rect rx="3" width="${totalWidth}" height="20" fill="url(#smooth)"/>
  <g fill="#fff" text-anchor="middle" font-family="DejaVu Sans,Verdana,Geneva,sans-serif" font-size="11">
    <text x="${labelWidth / 2}" y="15" fill="#010101" fill-opacity=".3">${label}</text>
    <text x="${labelWidth / 2}" y="14">${label}</text>
    <text x="${labelWidth + valueWidth / 2}" y="15" fill="#010101" fill-opacity=".3">${value}</text>
    <text x="${labelWidth + valueWidth / 2}" y="14">${value}</text>
  </g>
</svg>`;
  };

  // Bundle size badge
  const coreSize = report.suites.bundle?.results.find(r => r.name === 'core-bundle-gzip');
  if (coreSize) {
    const sizeKB = (coreSize.mean / 1024).toFixed(1);
    const color = coreSize.mean < 10240 ? '#4c1' : coreSize.mean < 51200 ? '#dfb317' : '#e05d44';
    const badge = generateBadgeSVG('size', `${sizeKB}KB`, color);
    await fs.writeFile(path.join(badgesDir, 'size.svg'), badge);
  }

  // Performance badge
  const create1k = report.suites.framework?.results.find(r => r.name === 'create-1000-rows');
  if (create1k) {
    const color = create1k.mean < 50 ? '#4c1' : create1k.mean < 100 ? '#dfb317' : '#e05d44';
    const badge = generateBadgeSVG('performance', `${create1k.mean.toFixed(0)}ms`, color);
    await fs.writeFile(path.join(badgesDir, 'performance.svg'), badge);
  }

  // Tests badge
  const color = report.summary.failed === 0 ? '#4c1' : '#e05d44';
  const badge = generateBadgeSVG('tests', `${report.summary.passed}/${report.summary.totalBenchmarks}`, color);
  await fs.writeFile(path.join(badgesDir, 'tests.svg'), badge);

  console.log(`âœ“ Badges generated in ${badgesDir}`);
}

/**
 * Main function.
 */
async function main(): Promise<void> {
  const options = parseArgs();

  console.log('ðŸ“¦ Publishing benchmark results...\n');

  // Load results
  const report = await loadLatestResults();

  // Create output directory
  await fs.mkdir(options.output, { recursive: true });

  // Publish in requested formats
  if (options.format === 'json' || options.format === 'all') {
    await publishJSON(report, options.output);
  }

  if (options.format === 'markdown' || options.format === 'all') {
    await publishMarkdown(report, options.output, options.includeComparison);
  }

  if (options.format === 'html' || options.format === 'all') {
    await publishHTML(report, options.output);
  }

  // Generate comparison charts
  if (options.generateCharts && report.suites.framework) {
    try {
      await generateAndSaveCharts(report, options.output);
    } catch (error) {
      console.warn('Warning: Could not generate comparison charts:', error);
    }
  }

  // Generate GitHub Pages site
  if (options.githubPages) {
    await publishGitHubPages(report, options.output);
  }

  // Generate badges
  if (options.createBadges) {
    await generateBadges(report, options.output);
  }

  console.log('\nâœ… Publishing complete!');
}

main().catch(error => {
  console.error('Error publishing results:', error);
  process.exit(1);
});
