/**
 * PhilJS Content Collections - Vite Plugin
 *
 * Provides build-time processing for content collections including:
 * - Type generation for collections
 * - Frontmatter extraction
 * - MDX compilation
 * - Image optimization
 * - Hot module replacement
 */

import { join, relative, resolve, dirname, basename, extname } from 'node:path';
import { readFile, writeFile, mkdir, stat, readdir } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import { globby } from 'globby';
import matter from 'gray-matter';
import chokidar from 'chokidar';
import imageSize from 'image-size';
import type { Plugin, ViteDevServer, ResolvedConfig } from 'vite';
import type {
  ContentPluginOptions,
  CollectionsConfig,
  CollectionDefinition,
  ContentBuildResult,
  ProcessedContent,
  ContentValidationError,
  ContentWatchEvent,
  ContentWatchCallback,
  ImageOptimizationOptions,
  ContentHeading,
  ContentImage,
} from './types.js';
import { validateEntryData, transformDates } from './collection.js';
import { setContentDir, setCollectionsConfig } from './query.js';

const VIRTUAL_MODULE_ID = 'virtual:philjs-content';
const RESOLVED_VIRTUAL_MODULE_ID = '\0' + VIRTUAL_MODULE_ID;
const CONTENT_CONFIG_ID = 'content/config';

/**
 * Default plugin options
 */
const defaultOptions: Required<ContentPluginOptions> = {
  contentDir: './content',
  typesOutput: './.philjs/content-types.d.ts',
  hmr: true,
  optimizeImages: true,
  imageOptions: {
    formats: ['webp'],
    sizes: [640, 1280, 1920],
    quality: 80,
    lazyLoad: true,
    outputDir: './.philjs/optimized-images',
  },
  remarkPlugins: [],
  rehypePlugins: [],
  watch: true,
};

/**
 * PhilJS Content Vite Plugin
 *
 * @example
 * ```typescript
 * // vite.config.ts
 * import { defineConfig } from 'vite';
 * import { contentPlugin } from 'philjs-content/vite';
 *
 * export default defineConfig({
 *   plugins: [
 *     contentPlugin({
 *       contentDir: './content',
 *       optimizeImages: true,
 *     }),
 *   ],
 * });
 * ```
 */
export function contentPlugin(userOptions: ContentPluginOptions = {}): Plugin {
  const options: Required<ContentPluginOptions> = {
    ...defaultOptions,
    ...userOptions,
    imageOptions: {
      ...defaultOptions.imageOptions,
      ...userOptions.imageOptions,
    },
  };

  let config: ResolvedConfig;
  let server: ViteDevServer | undefined;
  let collectionsConfig: CollectionsConfig | null = null;
  let watcher: chokidar.FSWatcher | undefined;
  let contentCache = new Map<string, ProcessedContent>();

  /**
   * Load content configuration from content/config.ts
   */
  async function loadContentConfig(): Promise<CollectionsConfig | null> {
    const configPath = resolve(options.contentDir, 'config.ts');

    if (!existsSync(configPath)) {
      console.warn(
        `[philjs-content] No content config found at ${configPath}`
      );
      return null;
    }

    try {
      // Import the config module
      const configModule = await import(configPath);
      return configModule.collections ?? null;
    } catch (error) {
      console.error('[philjs-content] Failed to load content config:', error);
      return null;
    }
  }

  /**
   * Generate TypeScript type definitions for collections
   */
  async function generateTypes(): Promise<string> {
    if (!collectionsConfig) {
      return '// No collections configured\n';
    }

    const lines: string[] = [
      '// Auto-generated by philjs-content',
      '// Do not edit this file directly',
      '',
      "declare module 'philjs-content' {",
      '  export interface ContentCollections {',
    ];

    for (const [name, config] of Object.entries(collectionsConfig)) {
      const collectionDir = join(options.contentDir, config.directory ?? name);

      // Get all files in the collection
      const patterns = config.type === 'content'
        ? ['**/*.md', '**/*.mdx']
        : ['**/*.json', '**/*.yaml', '**/*.yml'];

      try {
        const files = await globby(patterns, {
          cwd: collectionDir,
        });

        const ids = files.map((f) =>
          f.replace(/\.(md|mdx|json|yaml|yml)$/i, '')
        );

        lines.push(`    ${name}: {`);
        lines.push(`      type: '${config.type}';`);
        lines.push(`      ids: ${ids.length > 0 ? ids.map((id) => `'${id}'`).join(' | ') : 'string'};`);
        lines.push('    };');
      } catch {
        lines.push(`    ${name}: {`);
        lines.push(`      type: '${config.type}';`);
        lines.push('      ids: string;');
        lines.push('    };');
      }
    }

    lines.push('  }');
    lines.push('}');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Write type definitions to disk
   */
  async function writeTypes(): Promise<void> {
    const types = await generateTypes();
    const outputPath = resolve(options.typesOutput);
    const outputDir = dirname(outputPath);

    await mkdir(outputDir, { recursive: true });
    await writeFile(outputPath, types, 'utf-8');

    console.log(`[philjs-content] Generated types at ${outputPath}`);
  }

  /**
   * Process a single content file
   */
  async function processContentFile(
    filePath: string,
    collectionName: string,
    collectionConfig: CollectionDefinition
  ): Promise<ProcessedContent | null> {
    try {
      const content = await readFile(filePath, 'utf-8');
      const stats = await stat(filePath);

      let frontmatter: Record<string, unknown>;
      let body: string;

      const ext = extname(filePath).toLowerCase();

      if (ext === '.md' || ext === '.mdx') {
        const parsed = matter(content);
        frontmatter = parsed.data;
        body = parsed.content;
      } else if (ext === '.json') {
        frontmatter = JSON.parse(content);
        body = '';
      } else if (ext === '.yaml' || ext === '.yml') {
        const parsed = matter(`---\n${content}\n---`);
        frontmatter = parsed.data;
        body = '';
      } else {
        return null;
      }

      // Transform dates
      frontmatter = transformDates(frontmatter);

      // Validate against schema
      const result = validateEntryData(collectionConfig.schema, frontmatter);

      if (!result.success) {
        console.warn(
          `[philjs-content] Validation failed for ${filePath}:`,
          result.error.format()
        );
        return null;
      }

      // Extract headings and images
      const headings = extractHeadingsFromContent(body);
      const images = extractImagesFromContent(body);

      const collectionDir = join(options.contentDir, collectionConfig.directory ?? collectionName);
      const id = relative(collectionDir, filePath).replace(
        /\.(md|mdx|json|yaml|yml)$/i,
        ''
      );

      return {
        path: filePath,
        collection: collectionName,
        id,
        frontmatter: result.data,
        body,
        headings,
        images,
        mtime: stats.mtime,
      };
    } catch (error) {
      console.error(`[philjs-content] Failed to process ${filePath}:`, error);
      return null;
    }
  }

  /**
   * Extract headings from content
   */
  function extractHeadingsFromContent(content: string): ContentHeading[] {
    const headings: ContentHeading[] = [];
    const headingRegex = /^(#{1,6})\s+(.+)$/gm;

    let match;
    while ((match = headingRegex.exec(content)) !== null) {
      const depth = match[1].length;
      const text = match[2].trim();
      const slug = text
        .toLowerCase()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-');

      headings.push({ depth, text, slug });
    }

    return headings;
  }

  /**
   * Extract images from content
   */
  function extractImagesFromContent(content: string): ContentImage[] {
    const images: ContentImage[] = [];
    const mdImageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;

    let match;
    while ((match = mdImageRegex.exec(content)) !== null) {
      const image: ContentImage = {
        src: match[2],
        alt: match[1] || '',
      };

      // Try to get image dimensions
      try {
        const imagePath = resolve(options.contentDir, match[2]);
        if (existsSync(imagePath)) {
          const dimensions = imageSize(imagePath);
          image.width = dimensions.width;
          image.height = dimensions.height;
        }
      } catch {
        // Ignore errors getting image dimensions
      }

      images.push(image);
    }

    return images;
  }

  /**
   * Build all content
   */
  async function buildContent(): Promise<ContentBuildResult> {
    const startTime = Date.now();
    const entries: ProcessedContent[] = [];
    const errors: ContentValidationError[] = [];

    if (!collectionsConfig) {
      return {
        entries,
        errors,
        types: '',
        duration: Date.now() - startTime,
      };
    }

    for (const [name, config] of Object.entries(collectionsConfig)) {
      const collectionDir = join(options.contentDir, config.directory ?? name);

      const patterns = config.type === 'content'
        ? ['**/*.md', '**/*.mdx']
        : ['**/*.json', '**/*.yaml', '**/*.yml'];

      try {
        const files = await globby(patterns, {
          cwd: collectionDir,
          absolute: true,
        });

        for (const filePath of files) {
          const processed = await processContentFile(filePath, name, config);

          if (processed) {
            entries.push(processed);
            contentCache.set(filePath, processed);
          }
        }
      } catch {
        // Collection directory doesn't exist
      }
    }

    const types = await generateTypes();

    return {
      entries,
      errors,
      types,
      duration: Date.now() - startTime,
    };
  }

  /**
   * Set up file watching
   */
  function setupWatcher(): void {
    if (!options.watch || !collectionsConfig) {
      return;
    }

    const patterns: string[] = [];

    for (const [name, config] of Object.entries(collectionsConfig)) {
      const collectionDir = join(options.contentDir, config.directory ?? name);

      if (config.type === 'content') {
        patterns.push(join(collectionDir, '**/*.md'));
        patterns.push(join(collectionDir, '**/*.mdx'));
      } else {
        patterns.push(join(collectionDir, '**/*.json'));
        patterns.push(join(collectionDir, '**/*.yaml'));
        patterns.push(join(collectionDir, '**/*.yml'));
      }
    }

    watcher = chokidar.watch(patterns, {
      ignoreInitial: true,
      persistent: true,
    });

    watcher.on('add', async (path) => {
      console.log(`[philjs-content] File added: ${path}`);
      await handleFileChange(path, 'add');
    });

    watcher.on('change', async (path) => {
      console.log(`[philjs-content] File changed: ${path}`);
      await handleFileChange(path, 'change');
    });

    watcher.on('unlink', async (path) => {
      console.log(`[philjs-content] File removed: ${path}`);
      contentCache.delete(path);

      if (options.hmr && server) {
        server.ws.send({
          type: 'custom',
          event: 'philjs-content:update',
          data: { type: 'unlink', path },
        });
      }
    });
  }

  /**
   * Handle file change
   */
  async function handleFileChange(
    filePath: string,
    eventType: 'add' | 'change'
  ): Promise<void> {
    if (!collectionsConfig) {
      return;
    }

    // Find which collection this file belongs to
    for (const [name, config] of Object.entries(collectionsConfig)) {
      const collectionDir = resolve(options.contentDir, config.directory ?? name);

      if (filePath.startsWith(collectionDir)) {
        const processed = await processContentFile(filePath, name, config);

        if (processed) {
          contentCache.set(filePath, processed);

          // Trigger HMR
          if (options.hmr && server) {
            server.ws.send({
              type: 'custom',
              event: 'philjs-content:update',
              data: {
                type: eventType,
                collection: name,
                id: processed.id,
              },
            });
          }

          // Regenerate types if needed
          await writeTypes();
        }

        break;
      }
    }
  }

  /**
   * Generate virtual module code
   */
  function generateVirtualModule(): string {
    const entries = Array.from(contentCache.values());

    return `
// Virtual module generated by philjs-content
export const contentEntries = ${JSON.stringify(entries, null, 2)};

export function getCollection(name, filter) {
  const entries = contentEntries.filter(e => e.collection === name);
  return filter ? entries.filter(filter) : entries;
}

export function getEntry(collection, id) {
  return contentEntries.find(e => e.collection === collection && e.id === id);
}
`;
  }

  return {
    name: 'philjs-content',

    async configResolved(resolvedConfig) {
      config = resolvedConfig;

      // Resolve content directory
      options.contentDir = resolve(config.root, options.contentDir);
      options.typesOutput = resolve(config.root, options.typesOutput);

      // Set up query module
      setContentDir(options.contentDir);

      // Load collections config
      collectionsConfig = await loadContentConfig();

      if (collectionsConfig) {
        setCollectionsConfig(collectionsConfig);
      }
    },

    async configureServer(devServer) {
      server = devServer;

      // Build content on server start
      const result = await buildContent();
      console.log(
        `[philjs-content] Processed ${result.entries.length} entries in ${result.duration}ms`
      );

      // Generate types
      await writeTypes();

      // Set up file watching
      setupWatcher();
    },

    resolveId(id) {
      if (id === VIRTUAL_MODULE_ID) {
        return RESOLVED_VIRTUAL_MODULE_ID;
      }
      return null;
    },

    load(id) {
      if (id === RESOLVED_VIRTUAL_MODULE_ID) {
        return generateVirtualModule();
      }
      return null;
    },

    async buildStart() {
      // Load collections config
      if (!collectionsConfig) {
        collectionsConfig = await loadContentConfig();

        if (collectionsConfig) {
          setCollectionsConfig(collectionsConfig);
        }
      }

      // Build all content
      const result = await buildContent();
      console.log(
        `[philjs-content] Built ${result.entries.length} entries in ${result.duration}ms`
      );

      // Generate types
      await writeTypes();
    },

    async buildEnd() {
      // Clean up watcher
      if (watcher) {
        await watcher.close();
      }
    },

    // Handle .md and .mdx imports
    async transform(code, id) {
      if (!id.endsWith('.md') && !id.endsWith('.mdx')) {
        return null;
      }

      // Only process files in content directory
      if (!id.startsWith(options.contentDir)) {
        return null;
      }

      const { data, content } = matter(code);

      return {
        code: `
export const frontmatter = ${JSON.stringify(data)};
export const content = ${JSON.stringify(content)};
export default { frontmatter, content };
`,
        map: null,
      };
    },
  };
}

/**
 * Alias for contentPlugin
 */
export const philJSContent = contentPlugin;

/**
 * Default export
 */
export default contentPlugin;
