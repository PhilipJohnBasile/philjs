/**
 * FileRouter - Runtime component for file-based routing
 *
 * Renders the current route based on the file-based route manifest.
 */

import { signal, computed, effect, type Signal, type Computed } from '@philjs/core';

export interface FileRouterProps {
  /** Route manifest generated by the build plugin */
  manifest: RouteManifest;
  /** Initial path (defaults to window.location.pathname) */
  initialPath?: string;
  /** Custom 404 component */
  notFound?: () => unknown;
  /** Custom error boundary component */
  errorBoundary?: (props: { error: Error }) => unknown;
  /** Base path for all routes */
  basePath?: string;
  /** Enable hash-based routing */
  hashRouting?: boolean;
  /** Scroll behavior on navigation */
  scrollBehavior?: 'auto' | 'smooth' | 'none';
}

export interface RouteManifest {
  routes: RouteEntry[];
  layouts: Map<string, () => Promise<unknown>>;
}

export interface RouteEntry {
  path: string;
  pattern: RegExp;
  paramNames: string[];
  component: () => Promise<{ default: unknown }>;
  loader?: () => Promise<unknown>;
  layout?: string;
  middleware?: string[];
}

export interface RouteMatch {
  route: RouteEntry;
  params: Record<string, string>;
  searchParams: URLSearchParams;
}

interface RouterState {
  path: string;
  match: RouteMatch | null;
  isLoading: boolean;
  error: Error | null;
  data: unknown;
}

// Global router state
const routerState: Signal<RouterState> = signal({
  path: typeof window !== 'undefined' ? window.location.pathname : '/',
  match: null,
  isLoading: false,
  error: null,
  data: null,
});

// Navigation functions
export function navigate(path: string, options?: { replace?: boolean; scroll?: boolean }): void {
  const { replace = false, scroll = true } = options || {};

  if (replace) {
    window.history.replaceState({}, '', path);
  } else {
    window.history.pushState({}, '', path);
  }

  routerState.set({
    ...routerState.get(),
    path,
  });

  if (scroll) {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
}

export function back(): void {
  window.history.back();
}

export function forward(): void {
  window.history.forward();
}

// Route matching
function matchRoute(path: string, routes: RouteEntry[]): RouteMatch | null {
  const [pathname, search] = path.split('?');
  const searchParams = new URLSearchParams(search || '');

  for (const route of routes) {
    const match = route.pattern.exec(pathname);
    if (match) {
      const params: Record<string, string> = {};
      route.paramNames.forEach((name, i) => {
        params[name] = match[i + 1] || '';
      });
      return { route, params, searchParams };
    }
  }

  return null;
}

// Router context for child components
export const routerContext = {
  getPath: (): string => routerState.get().path,
  getParams: (): Record<string, string> => routerState.get().match?.params || {},
  getSearchParams: (): URLSearchParams =>
    routerState.get().match?.searchParams || new URLSearchParams(),
  getData: (): unknown => routerState.get().data,
  isLoading: (): boolean => routerState.get().isLoading,
  navigate,
  back,
  forward,
};

/**
 * FileRouter component - renders routes based on manifest
 */
export function FileRouter(props: FileRouterProps): unknown {
  const {
    manifest,
    initialPath,
    notFound,
    errorBoundary,
    basePath = '',
    hashRouting = false,
    scrollBehavior = 'auto',
  } = props;

  // Initialize path
  const getPath = (): string => {
    if (typeof window === 'undefined') {
      return initialPath || '/';
    }
    if (hashRouting) {
      return window.location.hash.slice(1) || '/';
    }
    const fullPath = window.location.pathname;
    return basePath ? fullPath.slice(basePath.length) || '/' : fullPath;
  };

  // Current path signal
  const currentPath = signal(getPath());

  // Current match (computed from path)
  const currentMatch: Computed<RouteMatch | null> = computed(() => {
    return matchRoute(currentPath.get(), manifest.routes);
  });

  // Loaded component signal
  const loadedComponent = signal<unknown>(null);
  const loaderData = signal<unknown>(null);
  const loadError = signal<Error | null>(null);
  const isLoading = signal(true);

  // Load route component and data
  async function loadRoute(match: RouteMatch | null): Promise<void> {
    if (!match) {
      isLoading.set(false);
      return;
    }

    isLoading.set(true);
    loadError.set(null);

    try {
      // Load component and data in parallel
      const [module, data] = await Promise.all([
        match.route.component(),
        match.route.loader?.() || Promise.resolve(null),
      ]);

      loadedComponent.set(module.default);
      loaderData.set(data);
      isLoading.set(false);

      // Handle scroll
      if (scrollBehavior !== 'none' && typeof window !== 'undefined') {
        window.scrollTo({
          top: 0,
          behavior: scrollBehavior === 'smooth' ? 'smooth' : 'auto',
        });
      }
    } catch (err) {
      loadError.set(err instanceof Error ? err : new Error(String(err)));
      isLoading.set(false);
    }
  }

  // Watch for route changes
  effect(() => {
    const match = currentMatch.get();
    loadRoute(match);
  });

  // Listen for browser navigation
  if (typeof window !== 'undefined') {
    const handlePopState = (): void => {
      currentPath.set(getPath());
    };

    window.addEventListener('popstate', handlePopState);

    // Cleanup on unmount would be handled by the framework
  }

  // Render logic
  return computed(() => {
    const error = loadError.get();
    if (error) {
      if (errorBoundary) {
        return errorBoundary({ error });
      }
      return createErrorElement(error);
    }

    if (isLoading.get()) {
      return createLoadingElement();
    }

    const match = currentMatch.get();
    if (!match) {
      if (notFound) {
        return notFound();
      }
      return createNotFoundElement();
    }

    const Component = loadedComponent.get() as ((props: unknown) => unknown) | null;
    if (!Component) {
      return null;
    }

    // Pass route data to component
    return Component({
      params: match.params,
      searchParams: match.searchParams,
      data: loaderData.get(),
    });
  });
}

// Default UI elements
function createLoadingElement(): unknown {
  return {
    type: 'div',
    props: {
      class: 'philjs-router-loading',
      children: 'Loading...',
    },
  };
}

function createNotFoundElement(): unknown {
  return {
    type: 'div',
    props: {
      class: 'philjs-router-404',
      children: [
        { type: 'h1', props: { children: '404' } },
        { type: 'p', props: { children: 'Page not found' } },
      ],
    },
  };
}

function createErrorElement(error: Error): unknown {
  return {
    type: 'div',
    props: {
      class: 'philjs-router-error',
      children: [
        { type: 'h1', props: { children: 'Error' } },
        { type: 'pre', props: { children: error.message } },
      ],
    },
  };
}

// Export router state for advanced usage
export { routerState };
