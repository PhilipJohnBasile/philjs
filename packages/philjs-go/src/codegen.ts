/**
 * Go Code Generator for PhilJS
 *
 * Generates Go server code from PhilJS routes and server functions.
 */

import { existsSync } from 'node:fs';
import { mkdir, writeFile, readFile, readdir } from 'node:fs/promises';
import { join, dirname, basename, extname } from 'node:path';
import type { GoRoute, GoMiddleware, GoServerFunction } from './types.js';

export interface CodegenOptions {
  /**
   * Source directory with server functions
   */
  srcDir: string;

  /**
   * Output directory for generated Go code
   */
  outDir: string;

  /**
   * Go module name
   */
  module: string;

  /**
   * Generate router code
   * @default true
   */
  router?: boolean;

  /**
   * Generate handler stubs
   * @default true
   */
  handlers?: boolean;

  /**
   * Generate types from TypeScript
   * @default true
   */
  types?: boolean;
}

/**
 * Generate Go server code from PhilJS configuration
 */
export async function generateGoCode(options: CodegenOptions): Promise<void> {
  const {
    srcDir,
    outDir,
    module,
    router = true,
    handlers = true,
    types = true,
  } = options;

  await mkdir(outDir, { recursive: true });

  // Scan for server functions
  const routes = await scanServerFunctions(srcDir);

  if (router) {
    await generateRouter(outDir, module, routes);
  }

  if (handlers) {
    await generateHandlers(outDir, module, routes);
  }

  if (types) {
    await generateTypes(outDir, module);
  }

  // Generate go.mod if not exists
  const goModPath = join(outDir, 'go.mod');
  if (!existsSync(goModPath)) {
    await generateGoMod(outDir, module);
  }
}

/**
 * Scan directory for server functions
 */
async function scanServerFunctions(srcDir: string): Promise<GoRoute[]> {
  const routes: GoRoute[] = [];

  if (!existsSync(srcDir)) {
    return routes;
  }

  const files = await readdir(srcDir, { recursive: true });

  for (const file of files) {
    if (typeof file !== 'string') continue;

    const ext = extname(file);
    if (ext !== '.ts' && ext !== '.js') continue;

    const filePath = join(srcDir, file);
    const content = await readFile(filePath, 'utf-8');

    // Parse server function exports
    const matches = content.matchAll(
      /export\s+(?:async\s+)?function\s+(GET|POST|PUT|DELETE|PATCH)\s*\(/g
    );

    for (const match of matches) {
      const method = match[1] as GoRoute['method'];
      const routePath = fileToRoutePath(file);

      routes.push({
        method,
        path: routePath,
        handler: `${method}_${pathToHandlerName(routePath)}`,
      });
    }
  }

  return routes;
}

/**
 * Convert file path to route path
 */
function fileToRoutePath(file: string): string {
  let route = file
    .replace(/\\/g, '/')
    .replace(/\.(ts|js)$/, '')
    .replace(/\/index$/, '')
    .replace(/\[([^\]]+)\]/g, ':$1'); // [id] -> :id

  if (!route.startsWith('/')) {
    route = '/' + route;
  }

  return route || '/';
}

/**
 * Convert path to Go handler name
 */
function pathToHandlerName(path: string): string {
  return path
    .replace(/^\//, '')
    .replace(/\//g, '_')
    .replace(/:/g, '')
    .replace(/-/g, '_')
    || 'root';
}

/**
 * Generate Go router code
 */
async function generateRouter(
  outDir: string,
  module: string,
  routes: GoRoute[]
): Promise<void> {
  const code = `// Code generated by @philjs/go. DO NOT EDIT.
package main

import (
    "github.com/philjs/philjs-go/server"
)

func RegisterRoutes(s *server.Server) {
${routes.map(r => `    s.${capitalize(r.method.toLowerCase())}("${r.path}", ${r.handler})`).join('\n')}
}
`;

  await writeFile(join(outDir, 'routes.go'), code);
}

/**
 * Generate Go handler stubs
 */
async function generateHandlers(
  outDir: string,
  module: string,
  routes: GoRoute[]
): Promise<void> {
  const handlersDir = join(outDir, 'handlers');
  await mkdir(handlersDir, { recursive: true });

  const code = `// Code generated by @philjs/go. DO NOT EDIT.
// Add your implementation to these handlers.
package main

import (
    "github.com/philjs/philjs-go/server"
)

${routes.map(r => `
func ${r.handler}(c *server.Context) error {
    // TODO: Implement ${r.method} ${r.path}
    return c.JSON(map[string]interface{}{
        "method": "${r.method}",
        "path":   "${r.path}",
    })
}
`).join('\n')}
`;

  await writeFile(join(handlersDir, 'handlers.go'), code);
}

/**
 * Generate Go types from TypeScript
 */
async function generateTypes(outDir: string, module: string): Promise<void> {
  const typesDir = join(outDir, 'types');
  await mkdir(typesDir, { recursive: true });

  const code = `// Code generated by @philjs/go. DO NOT EDIT.
package types

// Request represents an incoming HTTP request
type Request struct {
    Method  string            \`json:"method"\`
    URL     string            \`json:"url"\`
    Headers map[string]string \`json:"headers"\`
    Body    interface{}       \`json:"body,omitempty"\`
    Params  map[string]string \`json:"params,omitempty"\`
    Query   map[string]string \`json:"query,omitempty"\`
}

// Response represents an HTTP response
type Response struct {
    Status  int               \`json:"status"\`
    Headers map[string]string \`json:"headers,omitempty"\`
    Body    interface{}       \`json:"body,omitempty"\`
}

// SSRResult represents the result of server-side rendering
type SSRResult struct {
    HTML    string            \`json:"html"\`
    Head    string            \`json:"head"\`
    Scripts []string          \`json:"scripts"\`
    Styles  []string          \`json:"styles"\`
    State   interface{}       \`json:"state,omitempty"\`
}

// APIError represents an API error response
type APIError struct {
    Code    string \`json:"code"\`
    Message string \`json:"message"\`
    Details interface{} \`json:"details,omitempty"\`
}
`;

  await writeFile(join(typesDir, 'types.go'), code);
}

/**
 * Generate go.mod file
 */
async function generateGoMod(outDir: string, module: string): Promise<void> {
  const code = `module ${module}

go 1.22

require (
    github.com/philjs/philjs-go v0.1.0
)
`;

  await writeFile(join(outDir, 'go.mod'), code);
}

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

/**
 * Watch for changes and regenerate code
 */
export async function watchAndGenerate(options: CodegenOptions): Promise<void> {
  const { watch } = await import('node:fs');

  console.log(`Watching ${options.srcDir} for changes...`);

  watch(options.srcDir, { recursive: true }, async (event, filename) => {
    if (!filename) return;

    const ext = extname(filename);
    if (ext !== '.ts' && ext !== '.js') return;

    console.log(`Detected change in ${filename}, regenerating...`);
    await generateGoCode(options);
  });

  // Initial generation
  await generateGoCode(options);
}
