/**
 * PhilJS i18n Plugin
 *
 * Internationalization plugin for PhilJS with Vite integration,
 * automatic locale detection, and type-safe translations.
 */

import type { Plugin, PluginContext } from 'philjs-core/plugin-system';
import type { I18nPluginConfig, TranslationMap, ViteI18nPluginOptions } from './types.js';

/**
 * Minimal Vite plugin interface for compatibility
 */
interface VitePlugin {
  name: string;
  configResolved?(config: { root: string }): void;
  resolveId?(id: string): string | null | undefined;
  load?(id: string): string | null | Promise<string | null>;
  buildStart?(): Promise<void> | void;
  handleHotUpdate?(ctx: { file: string; server: { moduleGraph: { getModuleById: (id: string) => unknown } } }): unknown[] | undefined;
}

/**
 * Default configuration
 */
const defaultConfig: Partial<I18nPluginConfig> = {
  fallbackLocale: 'en',
  translationsDir: './src/locales',
  format: 'json',
  detectBrowserLocale: true,
  persistLocale: true,
  storageKey: 'philjs-locale',
  debug: false,
  onMissingTranslation: 'warn',
  urlStrategy: 'none',
  seo: true,
};

/**
 * Create i18n Vite plugin
 */
function createVitePlugin(options: ViteI18nPluginOptions): VitePlugin {
  const {
    translationsDir,
    virtualModuleId = 'virtual:philjs-i18n',
    generateTypes = true,
    typesOutputPath = './src/i18n.d.ts',
  } = options;

  const resolvedVirtualModuleId = '\0' + virtualModuleId;
  let root = '';

  return {
    name: 'philjs-i18n',

    configResolved(config: { root: string }) {
      root = config.root;
    },

    resolveId(id: string) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleId;
      }
      return undefined;
    },

    async load(id: string) {
      if (id === resolvedVirtualModuleId) {
        const { resolve, relative } = await import('path');
        const translationsPath = resolve(root, translationsDir);

        // Dynamic import for fast-glob
        const fg = await import('fast-glob');
        const files = await fg.glob('**/*.{json,yaml,yml,js,ts}', {
          cwd: translationsPath,
          absolute: false,
        });

        // Generate imports for each locale file
        const imports: string[] = [];
        const locales: string[] = [];

        for (const file of files) {
          // Extract locale from filename (e.g., en.json -> en, en-US.json -> en-US)
          const locale = file.replace(/\.(json|yaml|yml|js|ts)$/, '').replace(/\//g, '-');
          const relativePath = './' + relative(root, resolve(translationsPath, file)).replace(/\\/g, '/');

          imports.push(`import ${sanitizeIdentifier(locale)} from '${relativePath}';`);
          locales.push(locale);
        }

        // Generate the virtual module code
        return `
${imports.join('\n')}

export const translations = {
  ${locales.map(l => `'${l}': ${sanitizeIdentifier(l)}`).join(',\n  ')}
};

export const locales = ${JSON.stringify(locales)};

export function getTranslation(locale) {
  return translations[locale] || translations['${locales[0] || 'en'}'];
}
`;
      }
      return null;
    },

    async buildStart() {
      if (generateTypes) {
        await generateTypesFile(root, translationsDir, typesOutputPath);
      }
    },

    async handleHotUpdate({ file, server }) {
      const path = await import('path');
      const translationsPath = path.resolve(root, translationsDir);

      if (file.startsWith(translationsPath)) {
        const module = server.moduleGraph.getModuleById(resolvedVirtualModuleId);
        if (module) {
          return [module];
        }
      }
      return undefined;
    },
  };
}

/**
 * Sanitize a string to be a valid JavaScript identifier
 */
function sanitizeIdentifier(str: string): string {
  return str.replace(/[-./]/g, '_').replace(/^(\d)/, '_$1');
}

/**
 * Generate TypeScript types for translations
 */
async function generateTypesFile(
  root: string,
  translationsDir: string,
  outputPath: string
): Promise<void> {
  const { resolve, dirname } = await import('path');
  const { readFile, writeFile, mkdir } = await import('fs/promises');

  const translationsPath = resolve(root, translationsDir);

  try {
    // Try to read the default locale file
    const fg = await import('fast-glob');
    const files = await fg.glob('*.json', {
      cwd: translationsPath,
      absolute: true,
    });

    if (files.length === 0) return;

    // Read first locale file as reference
    const content = await readFile(files[0]!, 'utf-8');
    const translationsObj = JSON.parse(content) as TranslationMap;

    // Generate type definitions
    const types = generateTypeFromTranslations(translationsObj);

    const typeContent = `/**
 * Auto-generated i18n types
 * DO NOT EDIT - This file is generated by philjs-plugin-i18n
 */

declare module 'virtual:philjs-i18n' {
  export const translations: Record<string, TranslationMap>;
  export const locales: string[];
  export function getTranslation(locale: string): TranslationMap;
}

${types}

export type TranslationKey = keyof TranslationKeys;
`;

    const outPath = resolve(root, outputPath);
    await mkdir(dirname(outPath), { recursive: true });
    await writeFile(outPath, typeContent, 'utf-8');
  } catch {
    // Silently fail - types are optional
  }
}

/**
 * Generate TypeScript type from translation object
 */
function generateTypeFromTranslations(
  obj: TranslationMap,
  prefix = ''
): string {
  const lines: string[] = [];

  if (prefix === '') {
    lines.push('interface TranslationKeys {');
  }

  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;

    if (typeof value === 'string') {
      lines.push(`  '${fullKey}': string;`);
    } else if (typeof value === 'object' && value !== null) {
      const nested = generateTypeFromTranslations(value as TranslationMap, fullKey);
      lines.push(nested);
    }
  }

  if (prefix === '') {
    lines.push('}');
  }

  return lines.join('\n');
}

/**
 * Create i18n plugin
 */
export function createI18nPlugin(userConfig: I18nPluginConfig): Plugin {
  const config = { ...defaultConfig, ...userConfig } as Required<I18nPluginConfig>;

  return {
    meta: {
      name: 'philjs-plugin-i18n',
      version: '2.0.0',
      description: 'Internationalization plugin for PhilJS',
      author: 'PhilJS Team',
      homepage: 'https://philjs.dev/plugins/i18n',
      repository: 'https://github.com/yourusername/philjs',
      license: 'MIT',
      keywords: ['i18n', 'internationalization', 'localization', 'translations'],
      philjs: '^2.0.0',
    },

    configSchema: {
      type: 'object',
      required: ['defaultLocale', 'locales'],
      properties: {
        defaultLocale: {
          type: 'string',
          description: 'Default locale code',
        },
        locales: {
          type: 'array',
          description: 'Supported locale codes',
        },
        fallbackLocale: {
          type: 'string',
          description: 'Fallback locale when translation is missing',
        },
        translationsDir: {
          type: 'string',
          description: 'Directory containing translation files',
          default: './src/locales',
        },
        detectBrowserLocale: {
          type: 'boolean',
          description: 'Automatically detect browser locale',
          default: true,
        },
        persistLocale: {
          type: 'boolean',
          description: 'Persist locale selection to localStorage',
          default: true,
        },
        debug: {
          type: 'boolean',
          description: 'Enable debug mode',
          default: false,
        },
      },
    },

    vitePlugin(pluginConfig: I18nPluginConfig): any {
      const mergedConfig = { ...config, ...pluginConfig };

      return createVitePlugin({
        translationsDir: mergedConfig.translationsDir ?? './src/locales',
        generateTypes: true,
      });
    },

    async setup(pluginConfig: I18nPluginConfig, ctx: PluginContext) {
      const mergedConfig = { ...config, ...pluginConfig };

      ctx.logger.info('Setting up i18n...');

      // Create locales directory if it doesn't exist
      const localesDir = mergedConfig.translationsDir ?? './src/locales';

      try {
        const exists = await ctx.fs.exists(localesDir);
        if (!exists) {
          await ctx.fs.mkdir(localesDir);
          ctx.logger.success(`Created locales directory: ${localesDir}`);

          // Create default locale file
          const defaultTranslations = {
            common: {
              loading: 'Loading...',
              error: 'An error occurred',
              retry: 'Retry',
              cancel: 'Cancel',
              save: 'Save',
              delete: 'Delete',
              edit: 'Edit',
              confirm: 'Confirm',
            },
            validation: {
              required: 'This field is required',
              email: 'Please enter a valid email',
              minLength: 'Must be at least {{min}} characters',
              maxLength: 'Must be at most {{max}} characters',
            },
          };

          await ctx.fs.writeFile(
            `${localesDir}/${mergedConfig.defaultLocale}.json`,
            JSON.stringify(defaultTranslations, null, 2)
          );
          ctx.logger.success(`Created default translations: ${mergedConfig.defaultLocale}.json`);
        }
      } catch {
        ctx.logger.warn('Could not create locales directory');
      }

      // Generate client initialization file
      const localeArray = mergedConfig.locales.map(l =>
        typeof l === 'string' ? `'${l}'` : JSON.stringify(l)
      );

      const clientCode = `/**
 * i18n initialization
 * Auto-generated by philjs-plugin-i18n
 */

import { initI18n, t, setLocale, formatNumber, formatDate, formatCurrency } from 'philjs-plugin-i18n/client';
import { translations, locales } from 'virtual:philjs-i18n';

// Initialize i18n
initI18n({
  defaultLocale: '${mergedConfig.defaultLocale}',
  locales: [${localeArray.join(', ')}],
  translations,
  detectBrowserLocale: ${mergedConfig.detectBrowserLocale},
  persistLocale: ${mergedConfig.persistLocale},
  storageKey: '${mergedConfig.storageKey}',
});

// Re-export for convenience
export { t, setLocale, formatNumber, formatDate, formatCurrency };
export { locales, translations };
`;

      try {
        await ctx.fs.mkdir('src/lib');
        await ctx.fs.writeFile('src/lib/i18n.ts', clientCode);
        ctx.logger.success('Created i18n initialization file');
      } catch {
        ctx.logger.warn('Could not create i18n file, import directly from the package');
      }

      ctx.logger.success('i18n setup complete!');
      ctx.logger.info(`
Usage:
import { t, setLocale } from './lib/i18n';

// Translate
const greeting = t('common.greeting', { name: 'World' });

// Change locale
setLocale('es');
`);
    },

    hooks: {
      async init(ctx) {
        ctx.logger.debug('i18n plugin initialized');
      },

      async buildStart(ctx) {
        if (config.debug) {
          ctx.logger.debug(`i18n: ${config.locales.length} locales configured`);
        }
      },
    },
  };
}

/**
 * Default export
 */
export default createI18nPlugin;

/**
 * Re-export types
 */
export type {
  I18nPluginConfig,
  LocaleConfig,
  TranslationMap,
  TranslationValue,
  I18nContextValue,
  PluralRules,
  ViteI18nPluginOptions,
} from './types.js';

/**
 * Re-export client utilities
 */
export {
  currentLocale,
  initI18n,
  setLocale,
  loadTranslations,
  t,
  hasTranslation,
  useTranslation,
  formatNumber,
  formatDate,
  formatCurrency,
  formatRelativeTime,
  getI18nContext,
  getAvailableLocales,
  isRTL,
} from './client.js';
