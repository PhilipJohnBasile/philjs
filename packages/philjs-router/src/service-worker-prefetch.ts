/**
 * Service Worker Integration for Route Prefetching
 *
 * Provides:
 * - Background fetch for prefetched routes
 * - Stale-while-revalidate caching strategy
 * - Cache management for route modules and data
 * - Offline support for prefetched routes
 * - Communication channel between main thread and SW
 */

// ============================================================================
// Types
// ============================================================================

export interface PrefetchCacheConfig {
  /** Cache name for route modules */
  routeCacheName?: string;
  /** Cache name for route data */
  dataCacheName?: string;
  /** Maximum age for cached routes (ms) */
  maxAge?: number;
  /** Maximum number of cached routes */
  maxEntries?: number;
  /** Enable stale-while-revalidate */
  staleWhileRevalidate?: boolean;
}

export interface PrefetchMessage {
  type:
    | 'PREFETCH_REQUEST'
    | 'PREFETCH_COMPLETE'
    | 'CACHE_STATUS'
    | 'CLEAR_CACHE'
    | 'GET_CACHED_URLS';
  url?: string;
  urls?: string[];
  priority?: string;
  success?: boolean;
  cached?: boolean;
  error?: string;
  stats?: CacheStats;
}

export interface CacheStats {
  routeCount: number;
  dataCount: number;
  totalSize: number;
  oldestEntry: number;
  newestEntry: number;
}

export interface CachedRoute {
  url: string;
  timestamp: number;
  size: number;
  hasData: boolean;
}

// ============================================================================
// Constants
// ============================================================================

const DEFAULT_ROUTE_CACHE = 'philjs-route-cache-v1';
const DEFAULT_DATA_CACHE = 'philjs-data-cache-v1';
const DEFAULT_MAX_AGE = 24 * 60 * 60 * 1000; // 24 hours
const DEFAULT_MAX_ENTRIES = 50;
const BROADCAST_CHANNEL = 'philjs-prefetch';

// ============================================================================
// Service Worker Script Generator
// ============================================================================

/**
 * Generate service worker code for prefetch caching
 *
 * This can be used to generate a service worker script or inject into an existing one.
 *
 * @example
 * ```ts
 * const swCode = generatePrefetchServiceWorker({
 *   routeCacheName: 'my-app-routes',
 *   maxAge: 12 * 60 * 60 * 1000, // 12 hours
 * });
 *
 * // Write to file or register
 * ```
 */
export function generatePrefetchServiceWorker(config: PrefetchCacheConfig = {}): string {
  const routeCacheName = config.routeCacheName || DEFAULT_ROUTE_CACHE;
  const dataCacheName = config.dataCacheName || DEFAULT_DATA_CACHE;
  const maxAge = config.maxAge || DEFAULT_MAX_AGE;
  const maxEntries = config.maxEntries || DEFAULT_MAX_ENTRIES;
  const staleWhileRevalidate = config.staleWhileRevalidate ?? true;

  return `
// PhilJS Prefetch Service Worker
// Generated by philjs-router

const ROUTE_CACHE = '${routeCacheName}';
const DATA_CACHE = '${dataCacheName}';
const MAX_AGE = ${maxAge};
const MAX_ENTRIES = ${maxEntries};
const STALE_WHILE_REVALIDATE = ${staleWhileRevalidate};

// Broadcast channel for communication with main thread
let broadcastChannel;
try {
  broadcastChannel = new BroadcastChannel('${BROADCAST_CHANNEL}');
} catch (e) {
  // BroadcastChannel not supported
}

// ============================================================================
// Cache Management
// ============================================================================

async function cleanOldEntries(cacheName, maxAge, maxEntries) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  const now = Date.now();

  const entries = await Promise.all(
    keys.map(async (request) => {
      const response = await cache.match(request);
      const timestamp = response?.headers.get('x-prefetch-timestamp');
      return {
        request,
        timestamp: timestamp ? parseInt(timestamp, 10) : 0,
      };
    })
  );

  // Sort by timestamp (oldest first)
  entries.sort((a, b) => a.timestamp - b.timestamp);

  // Remove old entries
  for (const entry of entries) {
    const age = now - entry.timestamp;
    const tooOld = age > maxAge;
    const tooMany = entries.indexOf(entry) < entries.length - maxEntries;

    if (tooOld || tooMany) {
      await cache.delete(entry.request);
    }
  }
}

async function addToCache(cacheName, request, response) {
  const cache = await caches.open(cacheName);

  // Clone response and add timestamp header
  const clonedResponse = response.clone();
  const headers = new Headers(clonedResponse.headers);
  headers.set('x-prefetch-timestamp', Date.now().toString());

  const modifiedResponse = new Response(clonedResponse.body, {
    status: clonedResponse.status,
    statusText: clonedResponse.statusText,
    headers,
  });

  await cache.put(request, modifiedResponse);
  await cleanOldEntries(cacheName, MAX_AGE, MAX_ENTRIES);
}

async function getCacheStats() {
  const routeCache = await caches.open(ROUTE_CACHE);
  const dataCache = await caches.open(DATA_CACHE);

  const routeKeys = await routeCache.keys();
  const dataKeys = await dataCache.keys();

  let totalSize = 0;
  let oldestEntry = Date.now();
  let newestEntry = 0;

  for (const request of [...routeKeys, ...dataKeys]) {
    const cache = routeKeys.includes(request) ? routeCache : dataCache;
    const response = await cache.match(request);
    if (response) {
      const size = response.headers.get('content-length');
      if (size) totalSize += parseInt(size, 10);

      const timestamp = response.headers.get('x-prefetch-timestamp');
      if (timestamp) {
        const ts = parseInt(timestamp, 10);
        if (ts < oldestEntry) oldestEntry = ts;
        if (ts > newestEntry) newestEntry = ts;
      }
    }
  }

  return {
    routeCount: routeKeys.length,
    dataCount: dataKeys.length,
    totalSize,
    oldestEntry,
    newestEntry,
  };
}

// ============================================================================
// Fetch Handler
// ============================================================================

async function handleFetch(event) {
  const request = event.request;
  const url = new URL(request.url);

  // Only handle same-origin navigation requests
  if (request.mode !== 'navigate' && !request.headers.get('x-prefetch')) {
    return fetch(request);
  }

  // Check cache first
  const cache = await caches.open(ROUTE_CACHE);
  const cachedResponse = await cache.match(request);

  if (cachedResponse) {
    const timestamp = cachedResponse.headers.get('x-prefetch-timestamp');
    const age = timestamp ? Date.now() - parseInt(timestamp, 10) : MAX_AGE;

    if (age < MAX_AGE) {
      // Return cached response
      if (STALE_WHILE_REVALIDATE) {
        // Revalidate in background
        event.waitUntil(
          fetch(request)
            .then(response => {
              if (response.ok) {
                addToCache(ROUTE_CACHE, request, response);
              }
            })
            .catch(() => {})
        );
      }

      return cachedResponse;
    }
  }

  // Fetch from network
  try {
    const response = await fetch(request);

    if (response.ok) {
      event.waitUntil(addToCache(ROUTE_CACHE, request, response.clone()));
    }

    return response;
  } catch (error) {
    // Return cached response if available (even if stale)
    if (cachedResponse) {
      return cachedResponse;
    }
    throw error;
  }
}

// ============================================================================
// Message Handler
// ============================================================================

async function handleMessage(event) {
  const message = event.data;

  switch (message.type) {
    case 'PREFETCH_REQUEST': {
      try {
        const cache = await caches.open(ROUTE_CACHE);
        const cached = await cache.match(message.url);

        if (!cached) {
          const response = await fetch(message.url, {
            headers: { 'x-prefetch': 'true' },
          });

          if (response.ok) {
            await addToCache(ROUTE_CACHE, message.url, response);
          }
        }

        broadcastChannel?.postMessage({
          type: 'PREFETCH_COMPLETE',
          url: message.url,
          success: true,
          cached: !!cached,
        });
      } catch (error) {
        broadcastChannel?.postMessage({
          type: 'PREFETCH_COMPLETE',
          url: message.url,
          success: false,
          error: error.message,
        });
      }
      break;
    }

    case 'GET_CACHED_URLS': {
      const cache = await caches.open(ROUTE_CACHE);
      const keys = await cache.keys();
      const urls = keys.map(request => request.url);

      broadcastChannel?.postMessage({
        type: 'CACHE_STATUS',
        urls,
      });
      break;
    }

    case 'CLEAR_CACHE': {
      await caches.delete(ROUTE_CACHE);
      await caches.delete(DATA_CACHE);

      broadcastChannel?.postMessage({
        type: 'CACHE_STATUS',
        urls: [],
      });
      break;
    }
  }
}

// ============================================================================
// Event Listeners
// ============================================================================

self.addEventListener('install', (event) => {
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    Promise.all([
      self.clients.claim(),
      // Clean up old caches
      caches.keys().then(keys => {
        return Promise.all(
          keys
            .filter(key => key.startsWith('philjs-') && key !== ROUTE_CACHE && key !== DATA_CACHE)
            .map(key => caches.delete(key))
        );
      }),
    ])
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(handleFetch(event));
});

self.addEventListener('message', (event) => {
  handleMessage(event);
});

// Handle messages from BroadcastChannel
if (broadcastChannel) {
  broadcastChannel.onmessage = (event) => {
    handleMessage(event);
  };
}
`.trim();
}

// ============================================================================
// Main Thread API
// ============================================================================

let swChannel: BroadcastChannel | null = null;
let cachedUrls = new Set<string>();
const messageHandlers = new Map<string, (message: PrefetchMessage) => void>();

function createBroadcastChannel(name: string): BroadcastChannel | null {
  if (typeof BroadcastChannel === 'undefined') return null;

  const Channel = BroadcastChannel as unknown as {
    (channelName: string): BroadcastChannel;
    new (channelName: string): BroadcastChannel;
  };

  try {
    return Channel(name);
  } catch {
    try {
      return new Channel(name);
    } catch {
      return null;
    }
  }
}

/**
 * Initialize service worker communication
 */
export function initServiceWorkerPrefetch(): void {
  if (typeof window === 'undefined') return;

  try {
    swChannel = createBroadcastChannel(BROADCAST_CHANNEL);
    if (!swChannel) return;
    swChannel.onmessage = (event: MessageEvent<PrefetchMessage>) => {
      handleSwMessage(event.data);
    };

    // Request current cache status
    swChannel.postMessage({ type: 'GET_CACHED_URLS' });
  } catch {
    // BroadcastChannel not supported
  }
}

/**
 * Handle messages from service worker
 */
function handleSwMessage(message: PrefetchMessage): void {
  switch (message.type) {
    case 'PREFETCH_COMPLETE':
      if (message.url && message.success) {
        cachedUrls.add(message.url);
      }
      break;

    case 'CACHE_STATUS':
      if (message.urls) {
        cachedUrls = new Set(message.urls);
      }
      break;
  }

  // Call registered handlers
  const handler = messageHandlers.get(message.type);
  if (handler) {
    handler(message);
  }
}

/**
 * Request prefetch via service worker
 */
export function requestSwPrefetch(url: string, priority = 'low'): void {
  if (!swChannel) return;

  swChannel.postMessage({
    type: 'PREFETCH_REQUEST',
    url,
    priority,
  });
}

/**
 * Check if URL is cached in service worker
 */
export function isSwCached(url: string): boolean {
  return cachedUrls.has(url);
}

/**
 * Get all cached URLs
 */
export function getSwCachedUrls(): string[] {
  return Array.from(cachedUrls);
}

/**
 * Clear service worker cache
 */
export function clearSwCache(): void {
  if (!swChannel) return;
  swChannel.postMessage({ type: 'CLEAR_CACHE' });
  cachedUrls.clear();
}

/**
 * Register a message handler
 */
export function onSwMessage(
  type: PrefetchMessage['type'],
  handler: (message: PrefetchMessage) => void
): () => void {
  messageHandlers.set(type, handler);
  return () => messageHandlers.delete(type);
}

/**
 * Close service worker communication
 */
export function closeServiceWorkerPrefetch(): void {
  swChannel?.close();
  swChannel = null;
  cachedUrls.clear();
  messageHandlers.clear();
}

// ============================================================================
// Service Worker Registration Helper
// ============================================================================

export interface SwRegistrationOptions {
  /** Path to service worker file */
  swPath?: string;
  /** Scope for service worker */
  scope?: string;
  /** Called when SW is ready */
  onReady?: (registration: ServiceWorkerRegistration) => void;
  /** Called on registration error */
  onError?: (error: Error) => void;
  /** Called when SW is updated */
  onUpdate?: (registration: ServiceWorkerRegistration) => void;
}

/**
 * Register the prefetch service worker
 *
 * @example
 * ```ts
 * await registerPrefetchServiceWorker({
 *   swPath: '/sw.js',
 *   onReady: (registration) => {
 *     console.log('SW ready:', registration.scope);
 *   },
 * });
 * ```
 */
export async function registerPrefetchServiceWorker(
  options: SwRegistrationOptions = {}
): Promise<ServiceWorkerRegistration | null> {
  if (typeof navigator === 'undefined' || !('serviceWorker' in navigator)) {
    return null;
  }

  const swPath = options.swPath || '/sw.js';
  const scope = options.scope || '/';

  try {
    const registration = await navigator.serviceWorker.register(swPath, { scope });

    // Initialize communication
    initServiceWorkerPrefetch();

    // Handle updates
    registration.onupdatefound = () => {
      const installingWorker = registration.installing;
      if (!installingWorker) return;

      installingWorker.onstatechange = () => {
        if (installingWorker.state === 'installed') {
          if (navigator.serviceWorker.controller) {
            // New update available
            options.onUpdate?.(registration);
          } else {
            // Fresh install
            options.onReady?.(registration);
          }
        }
      };
    };

    // Already active
    if (registration.active) {
      options.onReady?.(registration);
    }

    return registration;
  } catch (error) {
    options.onError?.(error instanceof Error ? error : new Error(String(error)));
    return null;
  }
}

// ============================================================================
// Inline Service Worker (for development/testing)
// ============================================================================

/**
 * Create an inline service worker blob URL
 *
 * Useful for development or when you can't serve a separate SW file.
 *
 * @example
 * ```ts
 * const swUrl = createInlineServiceWorker();
 * await registerPrefetchServiceWorker({ swPath: swUrl });
 * ```
 */
export function createInlineServiceWorker(config?: PrefetchCacheConfig): string {
  if (typeof Blob === 'undefined' || typeof URL === 'undefined') {
    return '';
  }

  const swCode = generatePrefetchServiceWorker(config);
  const blob = new Blob([swCode], { type: 'application/javascript' });
  return URL.createObjectURL(blob);
}

// ============================================================================
// Stale-While-Revalidate Fetch Wrapper
// ============================================================================

export interface SWRFetchOptions {
  /** Maximum age for cached response (ms) */
  maxAge?: number;
  /** Cache name to use */
  cacheName?: string;
  /** Called when revalidation completes */
  onRevalidate?: (response: Response) => void;
}

/**
 * Fetch with stale-while-revalidate strategy
 *
 * Returns cached response immediately if available, while revalidating in background.
 *
 * @example
 * ```ts
 * const response = await swrFetch('/api/data', {
 *   maxAge: 5 * 60 * 1000, // 5 minutes
 *   onRevalidate: (freshResponse) => {
 *     console.log('Data updated');
 *   },
 * });
 * ```
 */
export async function swrFetch(
  url: string,
  options: SWRFetchOptions = {}
): Promise<Response> {
  const cacheName = options.cacheName || DEFAULT_DATA_CACHE;
  const maxAge = options.maxAge || DEFAULT_MAX_AGE;

  // Check cache first
  if (typeof caches !== 'undefined') {
    const cache = await caches.open(cacheName);
    const cachedResponse = await cache.match(url);

    if (cachedResponse) {
      const timestamp = cachedResponse.headers.get('x-prefetch-timestamp');
      const age = timestamp ? Date.now() - parseInt(timestamp, 10) : maxAge;

      if (age < maxAge) {
        // Revalidate in background
        fetch(url)
          .then(async (response) => {
            if (response.ok) {
              const headers = new Headers(response.headers);
              headers.set('x-prefetch-timestamp', Date.now().toString());

              const modifiedResponse = new Response(response.body, {
                status: response.status,
                statusText: response.statusText,
                headers,
              });

              await cache.put(url, modifiedResponse.clone());
              options.onRevalidate?.(modifiedResponse);
            }
          })
          .catch(() => {});

        return cachedResponse;
      }
    }
  }

  // Fetch from network
  const response = await fetch(url);

  // Cache successful responses
  if (response.ok && typeof caches !== 'undefined') {
    const cache = await caches.open(cacheName);
    const headers = new Headers(response.headers);
    headers.set('x-prefetch-timestamp', Date.now().toString());

    const modifiedResponse = new Response(response.clone().body, {
      status: response.status,
      statusText: response.statusText,
      headers,
    });

    await cache.put(url, modifiedResponse);
  }

  return response;
}
