{
  "PhilJS Island Component": {
    "prefix": ["pisland", "philisland"],
    "body": [
      "import { JSX, signal } from '@philjs/core';",
      "import { island } from 'philjs-islands';",
      "",
      "export default island(function ${1:ComponentName}() {",
      "\tconst ${2:count} = signal(${3:0});",
      "",
      "\treturn (",
      "\t\t<div>",
      "\t\t\t<p>Count: {${2:count}.get()}</p>",
      "\t\t\t<button onClick={() => ${2:count}.update(n => n + 1)}>",
      "\t\t\t\tIncrement",
      "\t\t\t</button>",
      "\t\t</div>",
      "\t);",
      "});"
    ],
    "description": "Create a PhilJS island component"
  },
  "PhilJS API Route": {
    "prefix": ["papi", "philapi"],
    "body": [
      "export async function GET(request: Request) {",
      "\t${1:// Handle GET request}",
      "\treturn new Response(JSON.stringify({ ${2:data} }), {",
      "\t\theaders: { 'Content-Type': 'application/json' },",
      "\t});",
      "}",
      "",
      "export async function POST(request: Request) {",
      "\tconst body = await request.json();",
      "\t${3:// Handle POST request}",
      "\treturn new Response(JSON.stringify({ ${4:success: true} }), {",
      "\t\theaders: { 'Content-Type': 'application/json' },",
      "\t});",
      "}"
    ],
    "description": "Create a PhilJS API route"
  },
  "PhilJS Loader": {
    "prefix": ["ploader", "philloader"],
    "body": [
      "export async function loader({ params, request }: LoaderArgs) {",
      "\t${1:// Load data}",
      "\treturn {",
      "\t\t${2:data}: ${3:null},",
      "\t};",
      "}"
    ],
    "description": "Create a PhilJS route loader"
  },
  "PhilJS Action": {
    "prefix": ["paction", "philaction"],
    "body": [
      "export async function action({ params, request }: ActionArgs) {",
      "\tconst formData = await request.formData();",
      "\t${1:// Handle form submission}",
      "\treturn {",
      "\t\t${2:success}: ${3:true},",
      "\t};",
      "}"
    ],
    "description": "Create a PhilJS form action"
  },
  "PhilJS Error Boundary": {
    "prefix": ["perror", "philerror"],
    "body": [
      "import { JSX, ErrorBoundary } from '@philjs/core';",
      "",
      "function ErrorFallback({ error }: { error: Error }) {",
      "\treturn (",
      "\t\t<div>",
      "\t\t\t<h1>Something went wrong</h1>",
      "\t\t\t<pre>{error.message}</pre>",
      "\t\t</div>",
      "\t);",
      "}",
      "",
      "export function ${1:ComponentName}() {",
      "\treturn (",
      "\t\t<ErrorBoundary fallback={<ErrorFallback />}>",
      "\t\t\t${2}",
      "\t\t</ErrorBoundary>",
      "\t);",
      "}"
    ],
    "description": "Create component with error boundary"
  },
  "PhilJS Suspense": {
    "prefix": ["psuspense", "philsuspense"],
    "body": [
      "import { JSX, Suspense } from '@philjs/core';",
      "",
      "function Loading() {",
      "\treturn <div>Loading...</div>;",
      "}",
      "",
      "export function ${1:ComponentName}() {",
      "\treturn (",
      "\t\t<Suspense fallback={<Loading />}>",
      "\t\t\t${2}",
      "\t\t</Suspense>",
      "\t);",
      "}"
    ],
    "description": "Create component with suspense"
  },
  "PhilJS Form": {
    "prefix": ["pform", "philform"],
    "body": [
      "import { JSX, signal } from '@philjs/core';",
      "",
      "export function ${1:FormName}() {",
      "\tconst ${2:formData} = signal({",
      "\t\t${3:name}: '',",
      "\t});",
      "",
      "\tconst handleSubmit = (e: Event) => {",
      "\t\te.preventDefault();",
      "\t\t${4:// Handle form submission}",
      "\t};",
      "",
      "\treturn (",
      "\t\t<form onSubmit={handleSubmit}>",
      "\t\t\t<input",
      "\t\t\t\ttype=\"text\"",
      "\t\t\t\tvalue={${2:formData}.get().${3:name}}",
      "\t\t\t\tonInput={(e) =>",
      "\t\t\t\t\t${2:formData}.update((prev) => ({ ...prev, ${3:name}: e.target.value }))",
      "\t\t\t\t}",
      "\t\t\t/>",
      "\t\t\t<button type=\"submit\">Submit</button>",
      "\t\t</form>",
      "\t);",
      "}"
    ],
    "description": "Create a PhilJS form component"
  },
  "PhilJS Async Effect": {
    "prefix": ["peffa", "phileffectasync"],
    "body": [
      "effect(() => {",
      "\tconst controller = new AbortController();",
      "",
      "\t(async () => {",
      "\t\ttry {",
      "\t\t\t${1:// Async operation}",
      "\t\t\tconst data = await fetch('${2:url}', { signal: controller.signal });",
      "\t\t\t${3:// Handle data}",
      "\t\t} catch (error) {",
      "\t\t\tif (error.name !== 'AbortError') {",
      "\t\t\t\tconsole.error(error);",
      "\t\t\t}",
      "\t\t}",
      "\t})();",
      "",
      "\treturn () => {",
      "\t\tcontroller.abort();",
      "\t};",
      "});"
    ],
    "description": "Create async effect with cleanup"
  },
  "PhilJS Test": {
    "prefix": ["ptest", "philtest"],
    "body": [
      "import { describe, it, expect } from 'vitest';",
      "import { render, screen, fireEvent } from 'philjs-testing';",
      "import { ${1:ComponentName} } from './${2:component}';",
      "",
      "describe('${1:ComponentName}', () => {",
      "\tit('renders correctly', () => {",
      "\t\trender(<${1:ComponentName} />);",
      "\t\texpect(screen.getByText('${3:text}')).toBeTruthy();",
      "\t});",
      "",
      "\tit('handles user interaction', async () => {",
      "\t\trender(<${1:ComponentName} />);",
      "\t\tconst button = screen.getByRole('button');",
      "\t\tawait fireEvent.click(button);",
      "\t\t${4:// Assertions}",
      "\t});",
      "});"
    ],
    "description": "Create a PhilJS component test"
  },
  "PhilJS SSR Component": {
    "prefix": ["pssr", "philssr"],
    "body": [
      "import { JSX } from '@philjs/core';",
      "import { renderToString } from 'philjs-ssr';",
      "",
      "export async function ${1:ComponentName}Server() {",
      "\t${2:// Server-side data fetching}",
      "\tconst data = ${3:null};",
      "",
      "\tconst html = await renderToString(",
      "\t\t<${1:ComponentName} data={data} />",
      "\t);",
      "",
      "\treturn html;",
      "}",
      "",
      "export function ${1:ComponentName}({ data }: { data: any }) {",
      "\treturn (",
      "\t\t<div>",
      "\t\t\t${4}",
      "\t\t</div>",
      "\t);",
      "}"
    ],
    "description": "Create SSR component with server function"
  },
  "PhilJS Middleware": {
    "prefix": ["pmiddleware", "philmiddleware"],
    "body": [
      "import type { Middleware } from 'philjs-router';",
      "",
      "export const ${1:middlewareName}: Middleware = async (request, next) => {",
      "\t${2:// Before request}",
      "\tconsole.log('Request:', request.url);",
      "",
      "\tconst response = await next();",
      "",
      "\t${3:// After request}",
      "\tconsole.log('Response:', response.status);",
      "",
      "\treturn response;",
      "};"
    ],
    "description": "Create middleware function"
  },
  "PhilJS Server Component": {
    "prefix": ["pserver", "philserver"],
    "body": [
      "import { JSX } from '@philjs/core';",
      "",
      "// Server Component - runs only on server",
      "export async function ${1:ComponentName}() {",
      "\tconst ${2:data} = await ${3:fetchData}();",
      "",
      "\treturn (",
      "\t\t<div>",
      "\t\t\t<h1>${4:Title}</h1>",
      "\t\t\t<pre>{JSON.stringify(${2:data}, null, 2)}</pre>",
      "\t\t</div>",
      "\t);",
      "}"
    ],
    "description": "Create a server component"
  },
  "PhilJS WebSocket": {
    "prefix": ["pws", "philwebsocket"],
    "body": [
      "import { signal, effect, onCleanup } from '@philjs/core';",
      "",
      "export function use${1:WebSocket}() {",
      "\tconst messages = signal<string[]>([]);",
      "\tconst connected = signal(false);",
      "",
      "\teffect(() => {",
      "\t\tconst ws = new WebSocket('${2:ws://localhost:3000}');",
      "",
      "\t\tws.onopen = () => connected.set(true);",
      "\t\tws.onclose = () => connected.set(false);",
      "",
      "\t\tws.onmessage = (event) => {",
      "\t\t\tmessages.update(prev => [...prev, event.data]);",
      "\t\t};",
      "",
      "\t\treturn () => {",
      "\t\t\tws.close();",
      "\t\t};",
      "\t});",
      "",
      "\treturn {",
      "\t\tmessages: messages.get(),",
      "\t\tconnected: connected.get(),",
      "\t};",
      "}"
    ],
    "description": "Create WebSocket hook"
  }
}
